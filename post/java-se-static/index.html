<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Java SE从入门到跑路（五·谁说一定要对象？static登场！） | SteamedFish&#39;s Blog</title>
<meta name="keywords" content="Java, Java SE, OOP, 教学, static">
<meta name="description" content="前言
当我们设计了一个类，然后根据这个类又new了一个对象，当这个对象被创建时，内存会为它分配一块空间，当我们创建多个对象时，他们各自占据一块内存
有些时候，我们并不想new一个对象，而是只是想使用某一个功能

想统计某个类被创建了多少次，结果发现得在外面数；
想在多个对象之间共享某个数据，比如“总人数”“游戏全局分数”等。

这时，static 关键字就登场了。
它的意思很简单：属于类，而不是属于对象。">
<meta name="author" content="">
<link rel="canonical" href="https://www.steamedfish.top/post/java-se-static/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.steamedfish.top/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.steamedfish.top/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.steamedfish.top/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://www.steamedfish.top/apple-touch-icon.png">
<link rel="mask-icon" href="https://www.steamedfish.top/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://www.steamedfish.top/post/java-se-static/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://www.steamedfish.top/post/java-se-static/">
  <meta property="og:site_name" content="SteamedFish&#39;s Blog">
  <meta property="og:title" content="Java SE从入门到跑路（五·谁说一定要对象？static登场！）">
  <meta property="og:description" content="前言 当我们设计了一个类，然后根据这个类又new了一个对象，当这个对象被创建时，内存会为它分配一块空间，当我们创建多个对象时，他们各自占据一块内存
有些时候，我们并不想new一个对象，而是只是想使用某一个功能
想统计某个类被创建了多少次，结果发现得在外面数； 想在多个对象之间共享某个数据，比如“总人数”“游戏全局分数”等。 这时，static 关键字就登场了。
它的意思很简单：属于类，而不是属于对象。">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2025-10-30T09:52:31+08:00">
    <meta property="article:modified_time" content="2025-10-30T03:09:10+00:00">
    <meta property="article:tag" content="Java">
    <meta property="article:tag" content="Java SE">
    <meta property="article:tag" content="OOP">
    <meta property="article:tag" content="教学">
    <meta property="article:tag" content="Static">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java SE从入门到跑路（五·谁说一定要对象？static登场！）">
<meta name="twitter:description" content="前言
当我们设计了一个类，然后根据这个类又new了一个对象，当这个对象被创建时，内存会为它分配一块空间，当我们创建多个对象时，他们各自占据一块内存
有些时候，我们并不想new一个对象，而是只是想使用某一个功能

想统计某个类被创建了多少次，结果发现得在外面数；
想在多个对象之间共享某个数据，比如“总人数”“游戏全局分数”等。

这时，static 关键字就登场了。
它的意思很简单：属于类，而不是属于对象。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://www.steamedfish.top/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Java SE从入门到跑路（五·谁说一定要对象？static登场！）",
      "item": "https://www.steamedfish.top/post/java-se-static/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java SE从入门到跑路（五·谁说一定要对象？static登场！）",
  "name": "Java SE从入门到跑路（五·谁说一定要对象？static登场！）",
  "description": "前言 当我们设计了一个类，然后根据这个类又new了一个对象，当这个对象被创建时，内存会为它分配一块空间，当我们创建多个对象时，他们各自占据一块内存\n有些时候，我们并不想new一个对象，而是只是想使用某一个功能\n想统计某个类被创建了多少次，结果发现得在外面数； 想在多个对象之间共享某个数据，比如“总人数”“游戏全局分数”等。 这时，static 关键字就登场了。\n它的意思很简单：属于类，而不是属于对象。\n",
  "keywords": [
    "Java", "Java SE", "OOP", "教学", "static"
  ],
  "articleBody": "前言 当我们设计了一个类，然后根据这个类又new了一个对象，当这个对象被创建时，内存会为它分配一块空间，当我们创建多个对象时，他们各自占据一块内存\n有些时候，我们并不想new一个对象，而是只是想使用某一个功能\n想统计某个类被创建了多少次，结果发现得在外面数； 想在多个对象之间共享某个数据，比如“总人数”“游戏全局分数”等。 这时，static 关键字就登场了。\n它的意思很简单：属于类，而不是属于对象。\n一、static 是什么？ static 是 Java 中的一个关键字，用来修饰 成员变量、方法、代码块 和 内部类。\n当某个成员被声明为 static 时：\n它不再属于某个对象； 而是被整个类共享； 在内存中只存在一份。 简单来说，就是：\n“类的属性，不用对象也能访问。”\n二、静态变量( static 修饰的变量) 我们先看一个例子：\nclass Student { String name; // 每个学生有自己的名字 static String school = \"芭乐高中\"; // 所有学生共用同一个学校名 } 使用方式：\npublic class Demo { public static void main(String[] args) { Student s1 = new Student(); s1.name = \"汪东城\"; Student s2 = new Student(); s2.name = \"雷婷\"; System.out.println(s1.name + \" - \" + s1.school); System.out.println(s2.name + \" - \" + s2.school); } } 输出结果：\n汪东城 - 芭乐高中 雷婷 - 芭乐高中 如果修改 school：\nStudent.school = \"热血高校\"; 再打印，你会发现所有对象看到的学校名都变了。\n汪东城 - 热血高校 雷婷 - 热血高校 这说明静态变量是共享的，而非独立的。\n三、静态方法( static 修饰的方法) 静态方法属于类，不依赖于对象。 也就是说，你可以直接用 类名调用，而不是对象名。 比如 Math.sqrt():\npublic class MathDemo { public static void main(String[] args) { double x = 9; double result = Math.sqrt(x); // 调用静态方法sqrt() System.out.println(result); // 输出3.0 } } 你不需要 new Math()，因为 sqrt() 是 static 的。\n这类方法一般具有通用性，与具体对象无关。\n你也可以自己写静态方法：\nclass Tool { public static void printLine() { System.out.println(\"----------静态方法运行了----------\"); } } 调用：\nTool.printLine(); 输出：\n----------静态方法运行了---------- 四、静态代码块( static 代码块) 静态代码块在类加载时自动执行一次，常用于初始化静态变量。\nclass InitDemo { static int count; static { System.out.println(\"静态代码块执行！\"); count = 10; } } 运行：\npublic class Test { public static void main(String[] args) { System.out.println(InitDemo.count); } } 输出：\n静态代码块执行！ 10 静态代码块只在类第一次被加载时运行一次，之后不会再执行。 它适合做一些全局初始化的工作。\n五、static 的内存原理 区域\r内容\r生命周期\r栈(Stack)\r方法中的局部变量\r方法调用时创建，结束时销毁\r堆(Heap)\r对象和实例变量\r使用 new 创建，垃圾回收时销毁\r方法区(Method Area)\r类信息、静态变量、常量\r程序运行期间始终存在\rstatic 成员就存放在方法区中，它随着类加载时一起被加载到方法区中\n因此，不论你创建多少个对象，它都只有一份拷贝。\n六、static 的注意事项 静态方法不能直接访问非静态成员。\nclass Demo { int a = 10; static int b = 20; static void show() { // System.out.println(a); ❌ 报错：不能访问非静态变量 System.out.println(b); // ✅ OK } } 因为静态方法在类加载时就存在，而非静态变量要等对象创建后才存在。\n静态方法中不能使用 this 或 super。\n因为它们属于对象，而 static 属于类。\n尽量避免滥用 static。\n“能用对象解决的，就不要滥用 static。”\n共享数据固然方便，但也会增加耦合和全局状态的复杂度。\n七、经典应用场景 场景\r示例\r说明\r工具类\rMath, Arrays, Collections\r不需要实例化\r常量类\rpublic static final double PI = 3.14159;\r定义全局常量\r计数器\r统计对象创建数量\r所有对象共享一个计数器\r单例模式\rprivate static 实例 + getInstance()\r确保类只有一个实例\r八、单例模式(Singleton Pattern) 单例模式（Singleton Pattern）是 Java 中非常经典的设计模式之一。 它的核心思想是：一个类在整个程序运行期间只能有一个对象存在。 这种模式经常用于：\n数据库连接对象 日志系统 配置管理器 游戏中“全局控制器”类等 而 static 正是实现单例模式的关键！\n单例模式分为\"懒汉式单例模式“和”饿汉式单例模式\"\n1.饿汉式( Eager Singleton) 饿汉式的特点是：类加载时就创建对象，不管你用不用，它都先准备好。\n优点是线程安全，简单直接；\n缺点是如果对象很大但暂时不用，会造成内存浪费。\nclass EagerSingleton { // 1. 在类加载时就创建唯一实例 private static final EagerSingleton instance = new EagerSingleton(); // 2. 构造函数私有化，防止外部new对象 private EagerSingleton() {} // 3. 提供全局访问点 public static EagerSingleton getInstance() { return instance; } } 使用方式：\npublic class Test { public static void main(String[] args) { EagerSingleton a = EagerSingleton.getInstance(); EagerSingleton b = EagerSingleton.getInstance(); System.out.println(a == b); // 输出 true，说明是同一个对象 } } 输出：\ntrue 2.懒汉式（Lazy Singleton） 懒汉式的特点是：第一次使用时才创建对象。 这样可以节省内存，但要注意线程安全问题。\nclass LazySingleton { private static LazySingleton instance; private LazySingleton() {} public static LazySingleton getInstance() { if (instance == null) { // 第一次调用时才创建对象 instance = new LazySingleton(); } return instance; } } 不过上面这个版本在多线程情况下会有安全问题。 所以更安全的写法是线程安全的懒汉式：\nclass SafeLazySingleton { private static SafeLazySingleton instance; private SafeLazySingleton() {} public static synchronized SafeLazySingleton getInstance() { if (instance == null) { instance = new SafeLazySingleton(); } return instance; } } 3.静态内部类式（推荐写法） 这是一种综合了“饿汉式的线程安全”和“懒汉式的延迟加载”的写法。 既安全又高效。\nclass Singleton { private Singleton() {} private static class Holder { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return Holder.INSTANCE; } } 这种写法利用了 Java 的类加载机制：\nHolder 类只有在第一次调用 getInstance() 时才会被加载； 而类加载是线程安全的； 因此不用手动加锁，也不会提前占用内存。 ",
  "wordCount" : "2084",
  "inLanguage": "zh",
  "datePublished": "2025-10-30T09:52:31+08:00",
  "dateModified": "2025-10-30T03:09:10.563051164Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.steamedfish.top/post/java-se-static/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "SteamedFish's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.steamedfish.top/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.steamedfish.top/" accesskey="h" title="SteamedFish&#39;s Blog (Alt + H)">SteamedFish&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.steamedfish.top/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://www.steamedfish.top/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://www.steamedfish.top/categories/" title="Categories">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://www.steamedfish.top/tags/" title="Tags">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://www.steamedfish.top/" title="搜索">
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://www.steamedfish.top/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://www.steamedfish.top/">主页</a>&nbsp;»&nbsp;<a href="https://www.steamedfish.top/post/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      Java SE从入门到跑路（五·谁说一定要对象？static登场！）
    </h1>
    <div class="post-meta"><span title='2025-10-30 09:52:31 +0800 +0800'>2025-10-30</span>&nbsp;·&nbsp;<span>5 分钟</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%89%8d%e8%a8%80" aria-label="前言">前言</a><ul>
                        
                <li>
                    <a href="#%e4%b8%80static-%e6%98%af%e4%bb%80%e4%b9%88" aria-label="一、static 是什么？">一、static 是什么？</a></li>
                <li>
                    <a href="#%e4%ba%8c%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f-static-%e4%bf%ae%e9%a5%b0%e7%9a%84%e5%8f%98%e9%87%8f" aria-label="二、静态变量( static 修饰的变量)">二、静态变量( static 修饰的变量)</a></li>
                <li>
                    <a href="#%e4%b8%89%e9%9d%99%e6%80%81%e6%96%b9%e6%b3%95-static-%e4%bf%ae%e9%a5%b0%e7%9a%84%e6%96%b9%e6%b3%95" aria-label="三、静态方法( static 修饰的方法)">三、静态方法( static 修饰的方法)</a></li>
                <li>
                    <a href="#%e5%9b%9b%e9%9d%99%e6%80%81%e4%bb%a3%e7%a0%81%e5%9d%97-static-%e4%bb%a3%e7%a0%81%e5%9d%97" aria-label="四、静态代码块( static 代码块)">四、静态代码块( static 代码块)</a></li>
                <li>
                    <a href="#%e4%ba%94static-%e7%9a%84%e5%86%85%e5%ad%98%e5%8e%9f%e7%90%86" aria-label="五、static 的内存原理">五、static 的内存原理</a></li>
                <li>
                    <a href="#%e5%85%adstatic-%e7%9a%84%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" aria-label="六、static 的注意事项">六、static 的注意事项</a></li>
                <li>
                    <a href="#%e4%b8%83%e7%bb%8f%e5%85%b8%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="七、经典应用场景">七、经典应用场景</a></li>
                <li>
                    <a href="#%e5%85%ab%e5%8d%95%e4%be%8b%e6%a8%a1%e5%bc%8fsingleton-pattern" aria-label="八、单例模式(Singleton Pattern)">八、单例模式(Singleton Pattern)</a><ul>
                        
                <li>
                    <a href="#1%e9%a5%bf%e6%b1%89%e5%bc%8f-eager-singleton" aria-label="1.饿汉式( Eager Singleton)">1.饿汉式( Eager Singleton)</a></li>
                <li>
                    <a href="#2%e6%87%92%e6%b1%89%e5%bc%8flazy-singleton" aria-label="2.懒汉式（Lazy Singleton）">2.懒汉式（Lazy Singleton）</a></li>
                <li>
                    <a href="#3%e9%9d%99%e6%80%81%e5%86%85%e9%83%a8%e7%b1%bb%e5%bc%8f%e6%8e%a8%e8%8d%90%e5%86%99%e6%b3%95" aria-label="3.静态内部类式（推荐写法）">3.静态内部类式（推荐写法）</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h1>
<p>当我们设计了一个类，然后根据这个类又new了一个对象，当这个对象被创建时，内存会为它分配一块空间，当我们创建多个对象时，他们各自占据一块内存<br>
有些时候，我们并不想new一个对象，而是只是想使用某一个功能</p>
<ul>
<li>想统计某个类被创建了多少次，结果发现得在外面数；</li>
<li>想在多个对象之间共享某个数据，比如“总人数”“游戏全局分数”等。</li>
</ul>
<p>这时，<code>static</code> 关键字就登场了。<br>
它的意思很简单：<strong>属于类，而不是属于对象</strong>。</p>
<hr>
<h2 id="一static-是什么">一、static 是什么？<a hidden class="anchor" aria-hidden="true" href="#一static-是什么">#</a></h2>
<p><code>static</code> 是 Java 中的一个关键字，用来修饰 <strong>成员变量</strong>、<strong>方法</strong>、<strong>代码块</strong> 和 <strong>内部类</strong>。</p>
<p>当某个成员被声明为 <code>static</code> 时：</p>
<ul>
<li>它<strong>不再属于某个对象</strong>；</li>
<li>而是被整个类<strong>共享</strong>；</li>
<li>在内存中<strong>只存在一份</strong>。</li>
</ul>
<p>简单来说，就是：</p>
<blockquote>
<p>“类的属性，不用对象也能访问。”</p>
</blockquote>
<hr>
<h2 id="二静态变量-static-修饰的变量">二、静态变量( static 修饰的变量)<a hidden class="anchor" aria-hidden="true" href="#二静态变量-static-修饰的变量">#</a></h2>
<p>我们先看一个例子：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Student</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">String</span><span class="w"> </span><span class="n">name</span><span class="p">;</span><span class="w">        </span><span class="c1">// 每个学生有自己的名字</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="n">String</span><span class="w"> </span><span class="n">school</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;芭乐高中&#34;</span><span class="p">;</span><span class="w"> </span><span class="c1">// 所有学生共用同一个学校名</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>使用方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Demo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Student</span><span class="w"> </span><span class="n">s1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Student</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">s1</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;汪东城&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">Student</span><span class="w"> </span><span class="n">s2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Student</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">s2</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;雷婷&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">s1</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; - &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s1</span><span class="p">.</span><span class="na">school</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">s2</span><span class="p">.</span><span class="na">name</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s">&#34; - &#34;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">s2</span><span class="p">.</span><span class="na">school</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>输出结果：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">汪东城</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">芭乐高中</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">雷婷</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">芭乐高中</span><span class="w">
</span></span></span></code></pre></div><p>如果修改 <code>school</code>：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Student</span><span class="p">.</span><span class="na">school</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;热血高校&#34;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></div><p>再打印，你会发现所有对象看到的学校名都变了。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">汪东城</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">热血高校</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">雷婷</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">热血高校</span><span class="w">
</span></span></span></code></pre></div><blockquote>
<p>这说明静态变量是共享的，而非独立的。</p>
</blockquote>
<hr>
<h2 id="三静态方法-static-修饰的方法">三、静态方法( static 修饰的方法)<a hidden class="anchor" aria-hidden="true" href="#三静态方法-static-修饰的方法">#</a></h2>
<p>静态方法属于类，不依赖于对象。   <br>
也就是说，你可以直接用 类名调用，而不是对象名。  <br>
比如 <code>Math.sqrt()</code>:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">MathDemo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">9</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kt">double</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="na">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">);</span><span class="w"> </span><span class="c1">// 调用静态方法sqrt()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">result</span><span class="p">);</span><span class="w"> </span><span class="c1">// 输出3.0</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>你不需要 <code>new Math()</code>，因为 <code>sqrt()</code> 是 <code>static</code> 的。<br>
这类方法一般具有<strong>通用性</strong>，与具体对象无关。</p>
<p>你也可以自己写静态方法：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Tool</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">printLine</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;----------静态方法运行了----------&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>调用：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="n">Tool</span><span class="p">.</span><span class="na">printLine</span><span class="p">();</span><span class="w">
</span></span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="o">----------</span><span class="n">静态方法运行了</span><span class="o">----------</span><span class="w">
</span></span></span></code></pre></div><hr>
<h2 id="四静态代码块-static-代码块">四、静态代码块( static 代码块)<a hidden class="anchor" aria-hidden="true" href="#四静态代码块-static-代码块">#</a></h2>
<p>静态代码块在<strong>类加载时自动执行一次</strong>，常用于初始化静态变量。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">InitDemo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">count</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">static</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="s">&#34;静态代码块执行！&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">count</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">10</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>运行：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Test</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">InitDemo</span><span class="p">.</span><span class="na">count</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>输出：</p>
<pre tabindex="0"><code>静态代码块执行！
10
</code></pre><p>静态代码块只在类第一次被加载时运行一次，之后不会再执行。 <br>
它适合做一些<strong>全局初始化</strong>的工作。</p>
<hr>
<h2 id="五static-的内存原理">五、static 的内存原理<a hidden class="anchor" aria-hidden="true" href="#五static-的内存原理">#</a></h2>




<table>

    <thead>
      <tr>
          <th>区域</th>
          <th>内容</th>
          <th>生命周期</th>
      </tr>
    </thead>
    <tbody>
    
    
        
        
        
      <tr>
        
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: "><strong>栈(Stack)</strong></td>
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">方法中的局部变量</td>
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">方法调用时创建，结束时销毁</td>
      </tr>
        
        
        
      <tr>
        
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: "><strong>堆(Heap)</strong></td>
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">对象和实例变量</td>
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">使用 <code>new</code> 创建，垃圾回收时销毁</td>
      </tr>
        
        
        
      <tr>
        
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: "><strong>方法区(Method Area)</strong></td>
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">类信息、静态变量、常量</td>
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">程序运行期间始终存在</td>
      </tr>
  </tbody>
</table><p><code>static</code> 成员就存放在方法区中，它随着类加载时一起被加载到方法区中<br>
因此，不论你创建多少个对象，它都只有<strong>一份拷贝</strong>。</p>
<hr>
<h2 id="六static-的注意事项">六、static 的注意事项<a hidden class="anchor" aria-hidden="true" href="#六static-的注意事项">#</a></h2>
<ol>
<li>
<p>静态方法<strong>不能直接访问非静态成员</strong>。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="w"> </span><span class="kd">class</span> <span class="nc">Demo</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">10</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="kd">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">20</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">show</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="c1">// System.out.println(a); ❌ 报错：不能访问非静态变量</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">         </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">b</span><span class="p">);</span><span class="w">   </span><span class="c1">// ✅ OK</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>因为静态方法在类加载时就存在，而非静态变量要等对象创建后才存在。</p>
</li>
<li>
<p>静态方法中不能使用 <code>this</code> 或 <code>super</code>。<br>
因为它们属于对象，而 <code>static</code> 属于类。</p>
</li>
<li>
<p>尽量避免滥用 static。</p>
<blockquote>
<p>“能用对象解决的，就不要滥用 static。”</p>
</blockquote>
<p>共享数据固然方便，但也会增加耦合和全局状态的复杂度。</p>
</li>
</ol>
<hr>
<h2 id="七经典应用场景">七、经典应用场景<a hidden class="anchor" aria-hidden="true" href="#七经典应用场景">#</a></h2>




<table>

    <thead>
      <tr>
          <th>场景</th>
          <th>示例</th>
          <th>说明</th>
      </tr>
    </thead>
    <tbody>
    
    
        
        
        
      <tr>
        
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">工具类</td>
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: "><code>Math</code>, <code>Arrays</code>, <code>Collections</code></td>
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">不需要实例化</td>
      </tr>
        
        
        
      <tr>
        
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">常量类</td>
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: "><code>public static final double PI = 3.14159;</code></td>
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">定义全局常量</td>
      </tr>
        
        
        
      <tr>
        
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">计数器</td>
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">统计对象创建数量</td>
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">所有对象共享一个计数器</td>
      </tr>
        
        
        
      <tr>
        
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">单例模式</td>
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: "><code>private static</code> 实例 + <code>getInstance()</code></td>
            
            
            
            
            
                
                
                
                
                
                
                
                
                
                
                
                <td rowspan="1" colspan="1" style="text-align: ">确保类只有一个实例</td>
      </tr>
  </tbody>
</table><hr>
<h2 id="八单例模式singleton-pattern">八、单例模式(Singleton Pattern)<a hidden class="anchor" aria-hidden="true" href="#八单例模式singleton-pattern">#</a></h2>
<p>单例模式（Singleton Pattern）是 Java 中非常经典的设计模式之一。
它的核心思想是：<strong>一个类在整个程序运行期间只能有一个对象存在</strong>。
这种模式经常用于：</p>
<ul>
<li>数据库连接对象</li>
<li>日志系统</li>
<li>配置管理器</li>
<li>游戏中“全局控制器”类等</li>
</ul>
<p>而 <code>static</code> 正是实现单例模式的关键！</p>
<p>单例模式分为&quot;<strong>懒汉式单例模式</strong>&ldquo;和&rdquo;<strong>饿汉式单例模式</strong>&quot;</p>
<h3 id="1饿汉式-eager-singleton">1.饿汉式( Eager Singleton)<a hidden class="anchor" aria-hidden="true" href="#1饿汉式-eager-singleton">#</a></h3>
<p>饿汉式的特点是：<strong>类加载时就创建对象</strong>，不管你用不用，它都先准备好。</p>
<p>优点是线程安全，简单直接；<br>
缺点是如果对象很大但暂时不用，会造成内存浪费。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">EagerSingleton</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 1. 在类加载时就创建唯一实例</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">EagerSingleton</span><span class="w"> </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">EagerSingleton</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 2. 构造函数私有化，防止外部new对象</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">EagerSingleton</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">// 3. 提供全局访问点</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">EagerSingleton</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>使用方式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Test</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">main</span><span class="p">(</span><span class="n">String</span><span class="o">[]</span><span class="w"> </span><span class="n">args</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">EagerSingleton</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EagerSingleton</span><span class="p">.</span><span class="na">getInstance</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">EagerSingleton</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EagerSingleton</span><span class="p">.</span><span class="na">getInstance</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">System</span><span class="p">.</span><span class="na">out</span><span class="p">.</span><span class="na">println</span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">// 输出 true，说明是同一个对象</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>输出：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kc">true</span><span class="w">
</span></span></span></code></pre></div><hr>
<h3 id="2懒汉式lazy-singleton">2.懒汉式（Lazy Singleton）<a hidden class="anchor" aria-hidden="true" href="#2懒汉式lazy-singleton">#</a></h3>
<p>懒汉式的特点是：<strong>第一次使用时才创建对象</strong>。 <br>
这样可以节省内存，但要注意线程安全问题。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">LazySingleton</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">LazySingleton</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">LazySingleton</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">LazySingleton</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">instance</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="c1">// 第一次调用时才创建对象</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">LazySingleton</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>不过上面这个版本在多线程情况下会有安全问题。 <br>
所以更安全的写法是线程安全的懒汉式：</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">SafeLazySingleton</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">SafeLazySingleton</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">SafeLazySingleton</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">synchronized</span><span class="w"> </span><span class="n">SafeLazySingleton</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">instance</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="kc">null</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="n">instance</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">SafeLazySingleton</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">instance</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><hr>
<h3 id="3静态内部类式推荐写法">3.静态内部类式（推荐写法）<a hidden class="anchor" aria-hidden="true" href="#3静态内部类式推荐写法">#</a></h3>
<p>这是一种综合了“饿汉式的线程安全”和“懒汉式的延迟加载”的写法。 <br>
既安全又高效。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="kd">class</span> <span class="nc">Singleton</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="nf">Singleton</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">class</span> <span class="nc">Holder</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="kd">private</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="kd">final</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="n">INSTANCE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">new</span><span class="w"> </span><span class="n">Singleton</span><span class="p">();</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kd">static</span><span class="w"> </span><span class="n">Singleton</span><span class="w"> </span><span class="nf">getInstance</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">Holder</span><span class="p">.</span><span class="na">INSTANCE</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div><p>这种写法利用了 Java 的类加载机制：</p>
<ul>
<li>Holder 类只有在第一次调用 getInstance() 时才会被加载；</li>
<li>而类加载是线程安全的；</li>
<li>因此不用手动加锁，也不会提前占用内存。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://www.steamedfish.top/tags/java/">Java</a></li>
      <li><a href="https://www.steamedfish.top/tags/java-se/">Java SE</a></li>
      <li><a href="https://www.steamedfish.top/tags/oop/">OOP</a></li>
      <li><a href="https://www.steamedfish.top/tags/%E6%95%99%E5%AD%A6/">教学</a></li>
      <li><a href="https://www.steamedfish.top/tags/static/">Static</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://www.steamedfish.top/">©2025 SteamedFish&rsquo;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
