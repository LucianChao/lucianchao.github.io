<!DOCTYPE html>
<html lang="zh" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>【微服务】RabbitMQ入门 | SteamedFish&#39;s Blog</title>
<meta name="keywords" content="RabbitMQ, 消息队列">
<meta name="description" content="前言
微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要 等待 服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们称这种调用方式为 同步调用 ，也可以叫 同步通讯 。但在很多场景下，我们可能需要采用 异步通讯 的方式，为什么呢？






    


       
    




  
    
  
    
  



">
<meta name="author" content="">
<link rel="canonical" href="https://www.steamedfish.top/post/microservices/6-mq/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.48569ef1d09dace3351ba549c3a7d634e59d1a68544f48e0de83f555e5c3e16e.css" integrity="sha256-SFae8dCdrOM1G6VJw6fWNOWdGmhUT0jg3oP1VeXD4W4=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://www.steamedfish.top/favicon.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://www.steamedfish.top/favicon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://www.steamedfish.top/favicon.png">
<link rel="apple-touch-icon" href="https://www.steamedfish.top/favicon.png">
<link rel="mask-icon" href="https://www.steamedfish.top/favicon.png">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://www.steamedfish.top/post/microservices/6-mq/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>





<link
  href="/fonts/lxgw/style.css"
  rel="stylesheet"
/><meta property="og:url" content="https://www.steamedfish.top/post/microservices/6-mq/">
  <meta property="og:site_name" content="SteamedFish&#39;s Blog">
  <meta property="og:title" content="【微服务】RabbitMQ入门">
  <meta property="og:description" content="前言 微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要 等待 服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们称这种调用方式为 同步调用 ，也可以叫 同步通讯 。但在很多场景下，我们可能需要采用 异步通讯 的方式，为什么呢？ ">
  <meta property="og:locale" content="zh">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2026-01-08T16:08:34+08:00">
    <meta property="article:modified_time" content="2026-01-09T01:39:55+08:00">
    <meta property="article:tag" content="RabbitMQ">
    <meta property="article:tag" content="消息队列">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【微服务】RabbitMQ入门">
<meta name="twitter:description" content="前言
微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要 等待 服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们称这种调用方式为 同步调用 ，也可以叫 同步通讯 。但在很多场景下，我们可能需要采用 异步通讯 的方式，为什么呢？






    


       
    




  
    
  
    
  



">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://www.steamedfish.top/post/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "【微服务】RabbitMQ入门",
      "item": "https://www.steamedfish.top/post/microservices/6-mq/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "【微服务】RabbitMQ入门",
  "name": "【微服务】RabbitMQ入门",
  "description": "前言 微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要 等待 服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们称这种调用方式为 同步调用 ，也可以叫 同步通讯 。但在很多场景下，我们可能需要采用 异步通讯 的方式，为什么呢？ ",
  "keywords": [
    "RabbitMQ", "消息队列"
  ],
  "articleBody": "前言 微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要 等待 服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们称这种调用方式为 同步调用 ，也可以叫 同步通讯 。但在很多场景下，我们可能需要采用 异步通讯 的方式，为什么呢？ MQ 同步调用 我们以黑马商城的余额支付为例： 优势 时效性强，等待到结果后才返回。 缺点 拓展性差 性能下降 级联失败 异步调用 异步调用通常是基于消息通知的方式，包含三个角色：\n消息发送者：投递消息的人，就是原来的调用者 消息代理：管理、暂存、转发消息，你可以把它理解成微信服务器 消息接收者：接收和处理消息的人，就是原来的服务提供者 支付服务不再同步调用业务关联度低的服务，而是发送消息通知到Broker。 具备下列优势： 解除耦合，拓展性强 无需等待，性能好 故障隔离 缓存消息，流量削峰填谷 缺点 不能立即得到调用结果，时效性差 不确定下游业务执行是否成功 业务安全依赖于Broker的可靠性 MQ技术选型 MQ （Message Queue），中文是消息队列，字面来看就是存放消息的队列。也就是异步调用中的 Broker。\nRabbitMQ\rActiveMQ\rRocketMQ\rKafka\r公司/社区\rRabbit\rApahce\r阿里\rApache\r开发语言\rErlang\rJava\rJava\rScala\u0026Java\r协议支持\rAMQP,XMPP,SMTP,STOMP\rOpenWire,STOMP,REST,XMPP,AMQP\r自定义协议\r自定义协议\r可用性\r高\r一般\r高\r高\r单机吞吐量\r一般\r差\r高\r非常高\r消息延迟\r微秒级\r毫秒级\r毫秒级\r毫秒以内\r消息可靠性\r高\r一般\r高\r一般\rRabbitMQ RabbitMQ是基于Erlang语言开发的开源消息通信中间件\n官网地址： https://www.rabbitmq.com/\n安装部署 基于Docker来安装RabbitMQ\ndocker run \\ -e RABBITMQ_DEFAULT_USER=itheima \\ -e RABBITMQ_DEFAULT_PASS=123321 \\ -v mq-plugins:/plugins \\ --name mq \\ --hostname mq \\ -p 15672:15672 \\ -p 5672:5672 \\ --network host \\ -d \\ rabbitmq:3.8-management 基本介绍 RabbitMQ的整体架构及核心概念： virtual-host：虚拟主机，起到数据隔离的作用 publisher：消息发送者 consumer：消息的消费者 queue：队列，存储消息 exchange：交换机，负责路由消息 交换机只能路由消息，无法存储消息 交换机只会路由消息给与其绑定的队列，因此队列必须与交换机绑定 快速入门 需求：在RabbitMQ的控制台完成下列操作:\n新建队列hello.queue1和hello.queue2 向默认的amp.fanout交换机发送一条消息 查看消息是否到达hello.queue1和hello.queue2 绑定（不用路由key）上述交换机与队列之后再发送 总结规律 数据隔离 需求：在RabbitMQ的控制台完成下列操作:\n新建一个用户hmall，密码123，权限administrator 为hmall用户创建一个virtual host 测试不同virtual host之间的数据隔离现象 Java客户端 SpringAmqp的官方地址： https://spring.io/projects/spring-amqp 快速入门 导入资料提供的Demo工程来测试： 需求如下： 利用控制台创建队列simple.queue 在publisher服务中，利用SpringAMQP直接向simple.queue发送消息 在consumer服务中，利用SpringAMQP编写消费者，监听simple.queue队列 步骤 在父工程中引入spring-amqp依赖，这样publisher和consumer服务都可以使用： org.springframework.boot spring-boot-starter-amqp 配置RabbitMQ服务端信息，在每个微服务中引入MQ服务端信息，这样微服务才能连接到RabbitMQ spring: rabbitmq: host: localhost #主机名 port: 5672 #端口 virtual-host: /hmall # 虚拟主机 username: hmall #用户名 password: 123 #密码 发送消息\nSpringAMQP提供了RabbitTemplate工具类，方便我们发送消息。发送消息代码如下： @Autowired private RabbitTemplate rabbitTemplate; // 向队列名称为simple.queue的队列发送消息 @Test public void testSimpleQueue() { // 队列的名称 String queueName = \"simple.queue\"; // 消息内容 String message = \"hello, spring amqp\"; // 使用简单队列的时候，可以不指定交换机：使用默认交换机 // 参数1：队列名称；参数2：消息内容 rabbitTemplate.convertAndSend(queueName,message); } 接收消息\nSpringAMQP提供声明式的消息监听，我们只需要通过注解在方法上声明要监听的队列名称，将来SpringAMQP就会把消息传递给当前方法： @Slf4j @Component public class SpringRabbitListener { // 从simple.queue队列中接收消息 @RabbitListener(queues = \"simple.queue\") public void listenSimpleQueue(String msg) { log.info(\"从simple.queue中接收到的消息：{}\", msg); } } WorkQueue Work queues，任务模型。简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。 多个消费者绑定到一个队列，可以加快消息处理速度 同一条消息只会被一个消费者处理 通过设置prefetch来控制消费者预取的消息数量，处理完一条再处理下一条，实现能者多劳 案例：模拟WorkQueue，实现一个队列绑定多个消费者 基本思路如下：\n在RabbitMQ的控制台创建一个队列，名为work.queue 在publisher服务中定义测试方法，发送50条消息到work.queue 在consumer服务中定义两个消息监听者，都监听work.queue队列 消费者1每秒处理40条消息，消费者2每秒处理5条消息 消费者消息推送限制 默认情况下，RabbitMQ会将消息依次轮询投递给绑定在队列上的每一个消费者。但这并没有考虑到消费者是否已经处理完消息，可能出现消息堆积。 因此我们需要修改application.yml，设置preFetch值为1，确保同一时刻最多投递给消费者1条消息：\n交换机 交换机的作用主要是接收发送者发送的消息，并将消息路由到与其绑定的队列。 常见交换机的类型有以下三种：\nFanout：广播 Direct：定向 Topic：话题 Fanout交换机 Fanout Exchange 会将接收到的消息路由到每一个跟其绑定的Queue，所以也叫广播模式 案例：利用SpringAMQP演示FanoutExchange的使用 实现思路如下：\n在RabbitMQ控制台中，声明队列fanout.queue1和fanout.queue2 在RabbitMQ控制台中，声明交换机hmall.fanout，将两个队列与其绑定 在consumer服务中，编写两个消费者方法，分别监听fanout.queue1和fanout.queue2 在publisher中编写测试方法，向hmall.fanout发送消息 Direct交换机 Direct Exchange 会将接收到的消息根据规则路由到指定的Queue，因此称为定向路由。 每一个Queue都与Exchange设置一个BindingKey 发布者发送消息时，指定消息的RoutingKey Exchange将消息路由到BindingKey与消息RoutingKey一致的队列 案例：利用SpringAMQP演示DirectExchange的使用 需求如下：\n在RabbitMQ控制台中，声明队列direct.queue1和direct.queue2 在RabbitMQ控制台中，声明交换机hmall. direct ，将两个队列与其绑定 在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2 在publisher中编写测试方法，利用不同的RoutingKey向hmall. direct发送消息 Topic交换机 TopicExchange与DirectExchange类似，区别在于routingKey可以是多个单词的列表，并且以 . 分割。\nQueue与Exchange指定BindingKey时可以使用通配符：\n#：代指0个或多个单词 *：代指一个单词 案例：利用SpringAMQP演示DirectExchange的使用 需求如下：\n在RabbitMQ控制台中，声明队列topic.queue1和topic.queue2 在RabbitMQ控制台中，声明交换机hmall. topic ，将两个队列与其绑定 在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2 在publisher中编写测试方法，利用不同的RoutingKey向hmall. topic发送消息 声明队列和交换机 SpringAMQP提供了几个类，用来声明队列、交换机及其绑定关系： Queue：用于声明队列，可以用工厂类QueueBuilder构建 Exchange：用于声明交换机，可以用工厂类ExchangeBuilder构建 Binding：用于声明队列和交换机的绑定关系，可以用工厂类BindingBuilder构建 例如，声明一个Fanout类型的交换机，并且创建队列与其绑定：\n消息转换器 需求：测试利用SpringAMQP发送对象类型的消息\n声明一个队列，名为object.queue 编写单元测试，向队列中直接发送一条消息，消息类型为Map 在控制台查看消息，总结你能发现的问题 ",
  "wordCount" : "3500",
  "inLanguage": "zh",
  "datePublished": "2026-01-08T16:08:34+08:00",
  "dateModified": "2026-01-09T01:39:55+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://www.steamedfish.top/post/microservices/6-mq/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "SteamedFish's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://www.steamedfish.top/favicon.png"
    }
  }
}
</script>
</head>

<body data-barba="wrapper" class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://www.steamedfish.top/" accesskey="h" title="SteamedFish&#39;s Blog (Alt + H)">SteamedFish&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                    <ul class="lang-switch"><li>|</li>
                        <li>
                            <a href="https://www.steamedfish.top/en/" title="English"
                                aria-label="English">En</a>
                        </li>
                    </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://www.steamedfish.top/" title="首页">
                    <span>首页</span>
                </a>
            </li>
            <li>
                <a href="https://www.steamedfish.top/archives/" title="归档">
                    <span>归档</span>
                </a>
            </li>
            <li>
                <a href="https://www.steamedfish.top/categories/" title="分类">
                    <span>分类</span>
                </a>
            </li>
            <li>
                <a href="https://www.steamedfish.top/tags/" title="标签">
                    <span>标签</span>
                </a>
            </li>
            <li>
                <a href="https://www.steamedfish.top/search/" title="搜索 (Alt &#43; /)" accesskey=/>
                    <span>搜索</span>
                </a>
            </li>
            <li>
                <a href="https://www.steamedfish.top/about/" title="关于">
                    <span>关于</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main" data-barba="container" data-barba-namespace="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      【微服务】RabbitMQ入门
    </h1>
    <div class="post-meta">






<span title='2026-01-08 16:08:34 +0800 +0800'>2026-01-08</span>&nbsp;·&nbsp;<span title='2026-01-09 01:39:55 +0800 +0800'>(最后修改于 2026-01-09)</span>&nbsp;·&nbsp;<span>7 分钟</span>&nbsp;|&nbsp;<span>
    <a href="https://github.com/LucianChao/Hugo_Blog/tree/main/content/post/microservices/6-MQ/index.md" rel="noopener noreferrer edit" target="_blank">编辑此文章</a>
</span>

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">目录</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%89%8d%e8%a8%80" aria-label="前言">前言</a></li>
                <li>
                    <a href="#mq" aria-label="MQ">MQ</a><ul>
                        
                <li>
                    <a href="#%e5%90%8c%e6%ad%a5%e8%b0%83%e7%94%a8" aria-label="同步调用">同步调用</a></li>
                <li>
                    <a href="#%e5%bc%82%e6%ad%a5%e8%b0%83%e7%94%a8" aria-label="异步调用">异步调用</a></li>
                <li>
                    <a href="#mq%e6%8a%80%e6%9c%af%e9%80%89%e5%9e%8b" aria-label="MQ技术选型">MQ技术选型</a></li></ul>
                </li>
                <li>
                    <a href="#rabbitmq" aria-label="RabbitMQ">RabbitMQ</a><ul>
                        
                <li>
                    <a href="#%e5%ae%89%e8%a3%85%e9%83%a8%e7%bd%b2" aria-label="安装部署">安装部署</a><ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e4%bb%8b%e7%bb%8d" aria-label="基本介绍">基本介绍</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8" aria-label="快速入门">快速入门</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e9%9a%94%e7%a6%bb" aria-label="数据隔离">数据隔离</a></li></ul>
                </li>
                <li>
                    <a href="#java%e5%ae%a2%e6%88%b7%e7%ab%af" aria-label="Java客户端">Java客户端</a><ul>
                        
                <li>
                    <a href="#%e5%bf%ab%e9%80%9f%e5%85%a5%e9%97%a8-1" aria-label="快速入门">快速入门</a><ul>
                        
                <li>
                    <a href="#%e6%ad%a5%e9%aa%a4" aria-label="步骤">步骤</a></li></ul>
                </li>
                <li>
                    <a href="#workqueue" aria-label="WorkQueue">WorkQueue</a><ul>
                        
                <li>
                    <a href="#%e6%a1%88%e4%be%8b%e6%a8%a1%e6%8b%9fworkqueue%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e9%98%9f%e5%88%97%e7%bb%91%e5%ae%9a%e5%a4%9a%e4%b8%aa%e6%b6%88%e8%b4%b9%e8%80%85" aria-label="案例：模拟WorkQueue，实现一个队列绑定多个消费者">案例：模拟WorkQueue，实现一个队列绑定多个消费者</a></li>
                <li>
                    <a href="#%e6%b6%88%e8%b4%b9%e8%80%85%e6%b6%88%e6%81%af%e6%8e%a8%e9%80%81%e9%99%90%e5%88%b6" aria-label="消费者消息推送限制">消费者消息推送限制</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%ba%a4%e6%8d%a2%e6%9c%ba" aria-label="交换机">交换机</a></li>
                <li>
                    <a href="#fanout%e4%ba%a4%e6%8d%a2%e6%9c%ba" aria-label="Fanout交换机">Fanout交换机</a><ul>
                        
                <li>
                    <a href="#%e6%a1%88%e4%be%8b%e5%88%a9%e7%94%a8springamqp%e6%bc%94%e7%a4%bafanoutexchange%e7%9a%84%e4%bd%bf%e7%94%a8" aria-label="案例：利用SpringAMQP演示FanoutExchange的使用">案例：利用SpringAMQP演示FanoutExchange的使用</a></li></ul>
                </li>
                <li>
                    <a href="#direct%e4%ba%a4%e6%8d%a2%e6%9c%ba" aria-label="Direct交换机">Direct交换机</a><ul>
                        
                <li>
                    <a href="#%e6%a1%88%e4%be%8b%e5%88%a9%e7%94%a8springamqp%e6%bc%94%e7%a4%badirectexchange%e7%9a%84%e4%bd%bf%e7%94%a8" aria-label="案例：利用SpringAMQP演示DirectExchange的使用">案例：利用SpringAMQP演示DirectExchange的使用</a></li></ul>
                </li>
                <li>
                    <a href="#topic%e4%ba%a4%e6%8d%a2%e6%9c%ba" aria-label="Topic交换机">Topic交换机</a><ul>
                        
                <li>
                    <a href="#%e6%a1%88%e4%be%8b%e5%88%a9%e7%94%a8springamqp%e6%bc%94%e7%a4%badirectexchange%e7%9a%84%e4%bd%bf%e7%94%a8-1" aria-label="案例：利用SpringAMQP演示DirectExchange的使用">案例：利用SpringAMQP演示DirectExchange的使用</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a3%b0%e6%98%8e%e9%98%9f%e5%88%97%e5%92%8c%e4%ba%a4%e6%8d%a2%e6%9c%ba" aria-label="声明队列和交换机">声明队列和交换机</a></li>
                <li>
                    <a href="#%e6%b6%88%e6%81%af%e8%bd%ac%e6%8d%a2%e5%99%a8" aria-label="消息转换器">消息转换器</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="前言">前言<a hidden class="anchor" aria-hidden="true" href="#前言">#</a></h2>
<p>微服务一旦拆分，必然涉及到服务之间的相互调用，目前我们服务之间调用采用的都是基于OpenFeign的调用。这种调用中，调用者发起请求后需要 <strong>等待</strong> 服务提供者执行业务返回结果后，才能继续执行后面的业务。也就是说调用者在调用过程中处于阻塞状态，因此我们称这种调用方式为 <strong>同步调用</strong> ，也可以叫 <strong>同步通讯</strong> 。但在很多场景下，我们可能需要采用 <strong>异步通讯</strong> 的方式，为什么呢？






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/1.gif"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/1.gif"
      srcset="/post/microservices/6-mq/1.gif 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>


</p>
<hr>
<h2 id="mq">MQ<a hidden class="anchor" aria-hidden="true" href="#mq">#</a></h2>
<h3 id="同步调用">同步调用<a hidden class="anchor" aria-hidden="true" href="#同步调用">#</a></h3>
<p>我们以黑马商城的余额支付为例：






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/2.png"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/2.png"
      srcset="/post/microservices/6-mq/2.png 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>


</p>
<ul>
<li>优势
<ul>
<li>时效性强，等待到结果后才返回。</li>
</ul>
</li>
<li>缺点
<ul>
<li>拓展性差</li>
<li>性能下降</li>
<li>级联失败</li>
</ul>
</li>
</ul>
<hr>
<h3 id="异步调用">异步调用<a hidden class="anchor" aria-hidden="true" href="#异步调用">#</a></h3>
<p>异步调用通常是基于消息通知的方式，包含三个角色：</p>
<ul>
<li>消息发送者：投递消息的人，就是原来的<strong>调用者</strong></li>
<li>消息代理：管理、暂存、转发消息，你可以把它理解成微信服务器</li>
<li>消息接收者：接收和处理消息的人，就是原来的<strong>服务提供者</strong>






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/3.png"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/3.png"
      srcset="/post/microservices/6-mq/3.png 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>



支付服务不再同步调用业务关联度低的服务，而是发送消息通知到<code>Broker</code>。






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/4.png"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/4.png"
      srcset="/post/microservices/6-mq/4.png 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>


</li>
<li>具备下列优势：
<ul>
<li>解除耦合，拓展性强</li>
<li>无需等待，性能好</li>
<li>故障隔离</li>
<li>缓存消息，流量削峰填谷






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/5.png"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/5.png"
      srcset="/post/microservices/6-mq/5.png 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>


</li>
</ul>
</li>
<li>缺点
<ul>
<li>不能立即得到调用结果，<strong>时效性差</strong></li>
<li>不确定下游业务执行是否成功</li>
<li>业务安全依赖于Broker的可靠性</li>
</ul>
</li>
</ul>
<hr>
<h3 id="mq技术选型">MQ技术选型<a hidden class="anchor" aria-hidden="true" href="#mq技术选型">#</a></h3>
<p>MQ （<strong>M</strong>essage <strong>Q</strong>ueue），中文是消息队列，字面来看就是存放消息的队列。也就是异步调用中的 <code>Broker</code>。</p>
<table class="table table-striped table-bordered table-hover">

  <thead>
      <tr>
          <th style="text-align: center"></th>
          <th style="text-align: center">RabbitMQ</th>
          <th style="text-align: center">ActiveMQ</th>
          <th style="text-align: center">RocketMQ</th>
          <th style="text-align: center">Kafka</th>
      </tr>
  </thead>

  <tbody>
    <tr>

        
<td style="text-align: center">公司/社区</td>

        
<td style="text-align: center"><code>Rabbit</code></td>

        
<td style="text-align: center"><code>Apahce</code></td>

        
<td style="text-align: center">阿里</td>

        
<td style="text-align: center"><code>Apache</code></td>
    </tr>
    <tr>

        
<td style="text-align: center">开发语言</td>

        
<td style="text-align: center"><code>Erlang</code></td>

        
<td style="text-align: center"><code>Java</code></td>

        
<td style="text-align: center"><code>Java</code></td>

        
<td style="text-align: center"><code>Scala</code>&amp;<code>Java</code></td>
    </tr>
    <tr>

        
<td style="text-align: center">协议支持</td>

        
<td style="text-align: center"><code>AMQP</code>,<code>XMPP</code>,<code>SMTP</code>,<code>STOMP</code></td>

        
<td style="text-align: center"><code>OpenWire</code>,<code>STOMP</code>,<code>REST</code>,<code>XMPP</code>,<code>AMQP</code></td>

        
<td style="text-align: center">自定义协议</td>

        
<td style="text-align: center">自定义协议</td>
    </tr>
    <tr>

        
<td style="text-align: center">可用性</td>

        
<td style="text-align: center">高</td>

        
<td style="text-align: center">一般</td>

        
<td style="text-align: center">高</td>

        
<td style="text-align: center">高</td>
    </tr>
    <tr>

        
<td style="text-align: center">单机吞吐量</td>

        
<td style="text-align: center">一般</td>

        
<td style="text-align: center">差</td>

        
<td style="text-align: center">高</td>

        
<td style="text-align: center">非常高</td>
    </tr>
    <tr>

        
<td style="text-align: center">消息延迟</td>

        
<td style="text-align: center">微秒级</td>

        
<td style="text-align: center">毫秒级</td>

        
<td style="text-align: center">毫秒级</td>

        
<td style="text-align: center">毫秒以内</td>
    </tr>
    <tr>

        
<td style="text-align: center">消息可靠性</td>

        
<td style="text-align: center">高</td>

        
<td style="text-align: center">一般</td>

        
<td style="text-align: center">高</td>

        
<td style="text-align: center">一般</td>
    </tr>
  </tbody>
</table><hr>
<h2 id="rabbitmq">RabbitMQ<a hidden class="anchor" aria-hidden="true" href="#rabbitmq">#</a></h2>
<p>RabbitMQ是基于Erlang语言开发的开源消息通信中间件<br>
官网地址： <a href="https://www.rabbitmq.com/">https://www.rabbitmq.com/</a></p>
<hr>
<h3 id="安装部署">安装部署<a hidden class="anchor" aria-hidden="true" href="#安装部署">#</a></h3>
<p>基于<code>Docker</code>来安装<code>RabbitMQ</code></p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">docker run <span class="se">\
</span></span></span><span class="line"><span class="cl"> -e <span class="nv">RABBITMQ_DEFAULT_USER</span><span class="o">=</span>itheima <span class="se">\
</span></span></span><span class="line"><span class="cl"> -e <span class="nv">RABBITMQ_DEFAULT_PASS</span><span class="o">=</span><span class="m">123321</span> <span class="se">\
</span></span></span><span class="line"><span class="cl"> -v mq-plugins:/plugins <span class="se">\
</span></span></span><span class="line"><span class="cl"> --name mq <span class="se">\
</span></span></span><span class="line"><span class="cl"> --hostname mq <span class="se">\
</span></span></span><span class="line"><span class="cl"> -p 15672:15672 <span class="se">\
</span></span></span><span class="line"><span class="cl"> -p 5672:5672 <span class="se">\
</span></span></span><span class="line"><span class="cl"> --network host <span class="se">\
</span></span></span><span class="line"><span class="cl"> -d <span class="se">\
</span></span></span><span class="line"><span class="cl"> rabbitmq:3.8-management
</span></span></code></pre></div><hr>
<h4 id="基本介绍">基本介绍<a hidden class="anchor" aria-hidden="true" href="#基本介绍">#</a></h4>
<p>RabbitMQ的整体架构及核心概念：






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/6.png"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/6.png"
      srcset="/post/microservices/6-mq/6.png 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>


</p>
<ul>
<li><code>virtual-host</code>：虚拟主机，起到数据隔离的作用</li>
<li><code>publisher</code>：消息发送者</li>
<li><code>consumer</code>：消息的消费者</li>
<li><code>queue</code>：队列，存储消息</li>
<li><code>exchange</code>：交换机，负责路由消息
<ul>
<li>交换机只能路由消息，无法存储消息</li>
<li>交换机只会路由消息给与其绑定的队列，因此队列必须与交换机绑定</li>
</ul>
</li>
</ul>
<hr>
<h3 id="快速入门">快速入门<a hidden class="anchor" aria-hidden="true" href="#快速入门">#</a></h3>
<p>需求：在<code>RabbitMQ</code>的控制台完成下列操作:</p>
<ul>
<li>新建队列<code>hello.queue1</code>和<code>hello.queue2</code></li>
<li>向默认的<code>amp.fanout</code>交换机发送一条消息</li>
<li>查看消息是否到达<code>hello.queue1</code>和<code>hello.queue2</code></li>
<li>绑定（不用路由<code>key</code>）上述交换机与队列之后再发送</li>
<li>总结规律</li>
</ul>
<hr>
<h3 id="数据隔离">数据隔离<a hidden class="anchor" aria-hidden="true" href="#数据隔离">#</a></h3>
<p>需求：在RabbitMQ的控制台完成下列操作:</p>
<ul>
<li>新建一个用户<code>hmall</code>，密码<code>123</code>，权限<code>administrator</code></li>
<li>为<code>hmall</code>用户创建一个<code>virtual host</code></li>
<li>测试不同<code>virtual host</code>之间的数据隔离现象</li>
</ul>
<hr>
<h2 id="java客户端">Java客户端<a hidden class="anchor" aria-hidden="true" href="#java客户端">#</a></h2>
<p>SpringAmqp的官方地址： <a href="https://spring.io/projects/spring-amqp">https://spring.io/projects/spring-amqp</a>






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/7.png"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/7.png"
      srcset="/post/microservices/6-mq/7.png 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>


</p>
<hr>
<h3 id="快速入门-1">快速入门<a hidden class="anchor" aria-hidden="true" href="#快速入门-1">#</a></h3>
<p>导入资料提供的<code>Demo</code>工程来测试：
需求如下：






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/8.png"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/8.png"
      srcset="/post/microservices/6-mq/8.png 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>


</p>
<ul>
<li>利用控制台创建队列<code>simple.queue</code>






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/9.webp"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/9.webp"
      srcset="/post/microservices/6-mq/9.webp 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>


</li>
<li>在<code>publisher</code>服务中，利用<code>SpringAMQP</code>直接向<code>simple.queue</code>发送消息</li>
<li>在<code>consumer</code>服务中，利用<code>SpringAMQP</code>编写消费者，监听<code>simple.queue</code>队列</li>
</ul>
<hr>
<h4 id="步骤">步骤<a hidden class="anchor" aria-hidden="true" href="#步骤">#</a></h4>
<ol>
<li>在父工程中引入<code>spring-amqp</code>依赖，这样<code>publisher</code>和<code>consumer</code>服务都可以使用：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="line"><span class="cl"><span class="c">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;dependency&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;groupId&gt;</span>org.springframework.boot<span class="nt">&lt;/groupId&gt;</span>
</span></span><span class="line"><span class="cl">    <span class="nt">&lt;artifactId&gt;</span>spring-boot-starter-amqp<span class="nt">&lt;/artifactId&gt;</span>
</span></span><span class="line"><span class="cl"><span class="nt">&lt;/dependency&gt;</span>
</span></span></code></pre></div></li>
<li>配置<code>RabbitMQ</code>服务端信息，在每个微服务中引入<code>MQ</code>服务端信息，这样微服务才能连接到<code>RabbitMQ</code>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-yml" data-lang="yml"><span class="line"><span class="cl"><span class="nt">spring</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="nt">rabbitmq</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">localhost</span><span class="w"> </span><span class="c">#主机名</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">port</span><span class="p">:</span><span class="w"> </span><span class="m">5672</span><span class="w"> </span><span class="c">#端口</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">virtual-host</span><span class="p">:</span><span class="w"> </span><span class="l">/hmall</span><span class="w"> </span><span class="c"># 虚拟主机</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">username</span><span class="p">:</span><span class="w"> </span><span class="l">hmall</span><span class="w"> </span><span class="c">#用户名</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nt">password</span><span class="p">:</span><span class="w"> </span><span class="m">123</span><span class="w"> </span><span class="c">#密码</span><span class="w">
</span></span></span></code></pre></div></li>
<li>发送消息<br>
<code>SpringAMQP</code>提供了<code>RabbitTemplate</code>工具类，方便我们发送消息。发送消息代码如下：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="w"> </span><span class="nd">@Autowired</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="kd">private</span><span class="w"> </span><span class="n">RabbitTemplate</span><span class="w"> </span><span class="n">rabbitTemplate</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="c1">//     向队列名称为simple.queue的队列发送消息</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="nd">@Test</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">testSimpleQueue</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="c1">// 队列的名称</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">String</span><span class="w"> </span><span class="n">queueName</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;simple.queue&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="c1">//     消息内容</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">String</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;hello, spring amqp&#34;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="c1">// 使用简单队列的时候，可以不指定交换机：使用默认交换机</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="c1">// 参数1：队列名称；参数2：消息内容</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">     </span><span class="n">rabbitTemplate</span><span class="p">.</span><span class="na">convertAndSend</span><span class="p">(</span><span class="n">queueName</span><span class="p">,</span><span class="n">message</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"> </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
<li>接收消息<br>
<code>SpringAMQP</code>提供声明式的消息监听，我们只需要通过注解在方法上声明要监听的队列名称，将来<code>SpringAMQP</code>就会把消息传递给当前方法：
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="line"><span class="cl"><span class="nd">@Slf4j</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="nd">@Component</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="kd">public</span><span class="w"> </span><span class="kd">class</span> <span class="nc">SpringRabbitListener</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="c1">//     从simple.queue队列中接收消息</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="nd">@RabbitListener</span><span class="p">(</span><span class="n">queues</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;simple.queue&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="kd">public</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">listenSimpleQueue</span><span class="p">(</span><span class="n">String</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="n">log</span><span class="p">.</span><span class="na">info</span><span class="p">(</span><span class="s">&#34;从simple.queue中接收到的消息：{}&#34;</span><span class="p">,</span><span class="w"> </span><span class="n">msg</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">}</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="p">}</span><span class="w">
</span></span></span></code></pre></div></li>
</ol>
<hr>
<h3 id="workqueue">WorkQueue<a hidden class="anchor" aria-hidden="true" href="#workqueue">#</a></h3>
<p><code>Work queues</code>，任务模型。简单来说就是让<strong>多个消费者绑定到一个队列，共同消费队列中的消息</strong>。






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/10.png"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/10.png"
      srcset="/post/microservices/6-mq/10.png 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>


</p>
<ul>
<li>多个消费者绑定到一个队列，可以加快消息处理速度</li>
<li>同一条消息只会被一个消费者处理</li>
<li>通过设置<code>prefetch</code>来控制消费者预取的消息数量，处理完一条再处理下一条，实现能者多劳</li>
</ul>
<hr>
<h4 id="案例模拟workqueue实现一个队列绑定多个消费者">案例：模拟WorkQueue，实现一个队列绑定多个消费者<a hidden class="anchor" aria-hidden="true" href="#案例模拟workqueue实现一个队列绑定多个消费者">#</a></h4>
<p>基本思路如下：</p>
<ol>
<li>在RabbitMQ的控制台创建一个队列，名为work.queue</li>
<li>在publisher服务中定义测试方法，发送50条消息到work.queue</li>
<li>在consumer服务中定义两个消息监听者，都监听work.queue队列</li>
<li>消费者1每秒处理40条消息，消费者2每秒处理5条消息</li>
</ol>
<hr>
<h4 id="消费者消息推送限制">消费者消息推送限制<a hidden class="anchor" aria-hidden="true" href="#消费者消息推送限制">#</a></h4>
<p>默认情况下，<code>RabbitMQ</code>会将消息依次轮询投递给绑定在队列上的每一个消费者。但这并没有考虑到消费者是否已经处理完消息，可能出现消息堆积。
因此我们需要修改<code>application.yml</code>，设置<code>preFetch</code>值为<code>1</code>，确保同一时刻最多投递给消费者<code>1</code>条消息：</p>
<hr>
<h3 id="交换机">交换机<a hidden class="anchor" aria-hidden="true" href="#交换机">#</a></h3>
<p>交换机的作用主要是接收发送者发送的消息，并将消息路由到与其绑定的队列。






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/11.png"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/11.png"
      srcset="/post/microservices/6-mq/11.png 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>



常见交换机的类型有以下三种：</p>
<ul>
<li><code>Fanout</code>：广播</li>
<li><code>Direct</code>：定向</li>
<li><code>Topic</code>：话题</li>
</ul>
<hr>
<h3 id="fanout交换机">Fanout交换机<a hidden class="anchor" aria-hidden="true" href="#fanout交换机">#</a></h3>
<p><code>Fanout Exchange</code> 会将接收到的消息路由到每一个跟其绑定的<code>Queue</code>，所以也叫广播模式






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/12.png"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/12.png"
      srcset="/post/microservices/6-mq/12.png 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>


</p>
<hr>
<h4 id="案例利用springamqp演示fanoutexchange的使用">案例：利用SpringAMQP演示FanoutExchange的使用<a hidden class="anchor" aria-hidden="true" href="#案例利用springamqp演示fanoutexchange的使用">#</a></h4>
<p>实现思路如下：</p>
<ol>
<li>在<code>RabbitMQ</code>控制台中，声明队列<code>fanout.queue1</code>和<code>fanout.queue2</code></li>
<li>在<code>RabbitMQ</code>控制台中，声明交换机<code>hmall.fanout</code>，将两个队列与其绑定</li>
<li>在<code>consumer</code>服务中，编写两个消费者方法，分别监听<code>fanout.queue1</code>和<code>fanout.queue2</code></li>
<li>在<code>publisher</code>中编写测试方法，向<code>hmall.fanout</code>发送消息</li>
</ol>
<hr>
<h3 id="direct交换机">Direct交换机<a hidden class="anchor" aria-hidden="true" href="#direct交换机">#</a></h3>
<p><code>Direct Exchange</code> 会将接收到的消息根据规则路由到指定的<code>Queue</code>，因此称为定向路由。






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/13.png"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/13.png"
      srcset="/post/microservices/6-mq/13.png 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>


</p>
<ul>
<li>每一个<code>Queue</code>都与<code>Exchange</code>设置一个<code>BindingKey</code></li>
<li>发布者发送消息时，指定消息的<code>RoutingKey</code></li>
<li><code>Exchange</code>将消息路由到<code>BindingKey</code>与消息<code>RoutingKey</code>一致的队列</li>
</ul>
<hr>
<h4 id="案例利用springamqp演示directexchange的使用">案例：利用SpringAMQP演示DirectExchange的使用<a hidden class="anchor" aria-hidden="true" href="#案例利用springamqp演示directexchange的使用">#</a></h4>
<p>需求如下：</p>
<ol>
<li>在<code>RabbitMQ</code>控制台中，声明队列<code>direct.queue1</code>和<code>direct.queue2</code></li>
<li>在<code>RabbitMQ</code>控制台中，声明交换机<code>hmall. direct</code> ，将两个队列与其绑定</li>
<li>在<code>consumer</code>服务中，编写两个消费者方法，分别监听<code>direct.queue1</code>和<code>direct.queue2</code></li>
<li>在<code>publisher</code>中编写测试方法，利用不同的<code>RoutingKey</code>向<code>hmall. direct</code>发送消息</li>
</ol>
<hr>
<h3 id="topic交换机">Topic交换机<a hidden class="anchor" aria-hidden="true" href="#topic交换机">#</a></h3>
<p><code>TopicExchange</code>与<code>DirectExchange</code>类似，区别在于<code>routingKey</code>可以是多个单词的列表，并且以 <code>.</code> 分割。<br>






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/14.png"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/14.png"
      srcset="/post/microservices/6-mq/14.png 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>



<code>Queue</code>与<code>Exchange</code>指定<code>BindingKey</code>时可以使用通配符：</p>
<ul>
<li><code>#</code>：代指<code>0</code>个或多个单词</li>
<li><code>*</code>：代指一个单词</li>
</ul>
<hr>
<h4 id="案例利用springamqp演示directexchange的使用-1">案例：利用SpringAMQP演示DirectExchange的使用<a hidden class="anchor" aria-hidden="true" href="#案例利用springamqp演示directexchange的使用-1">#</a></h4>
<p>需求如下：</p>
<ol>
<li>在<code>RabbitMQ</code>控制台中，声明队列<code>topic.queue1</code>和<code>topic.queue2</code></li>
<li>在<code>RabbitMQ</code>控制台中，声明交换机<code>hmall. topic</code> ，将两个队列与其绑定</li>
<li>在<code>consumer</code>服务中，编写两个消费者方法，分别监听<code>topic.queue1</code>和<code>topic.queue2</code></li>
<li>在<code>publisher</code>中编写测试方法，利用不同的<code>RoutingKey</code>向<code>hmall. topic</code>发送消息</li>
</ol>
<hr>
<h3 id="声明队列和交换机">声明队列和交换机<a hidden class="anchor" aria-hidden="true" href="#声明队列和交换机">#</a></h3>
<p>SpringAMQP提供了几个类，用来声明队列、交换机及其绑定关系：






    


       
    



<div class="post-img-view">
  <a
    data-fancybox="post-post/microservices/6-MQ/index.md"
    href="/post/microservices/6-mq/15.png"
    data-caption=""
    data-barba-prevent="all"
  >
    <img
      src="/post/microservices/6-mq/15.png"
      srcset="/post/microservices/6-mq/15.png 2x"
      alt=""
      loading="lazy"
      style="max-width: 100%; height: auto;"
    />
  </a>
    
  
</div>


</p>
<ul>
<li><code>Queue</code>：用于声明队列，可以用工厂类<code>QueueBuilder</code>构建</li>
<li><code>Exchange</code>：用于声明交换机，可以用工厂类<code>ExchangeBuilder</code>构建</li>
<li><code>Binding</code>：用于声明队列和交换机的绑定关系，可以用工厂类<code>BindingBuilder</code>构建</li>
</ul>
<p>例如，声明一个<code>Fanout</code>类型的交换机，并且创建队列与其绑定：</p>
<h3 id="消息转换器">消息转换器<a hidden class="anchor" aria-hidden="true" href="#消息转换器">#</a></h3>
<p>需求：测试利用<code>SpringAMQP</code>发送对象类型的消息</p>
<ol>
<li>声明一个队列，名为<code>object.queue</code></li>
<li>编写单元测试，向队列中直接发送一条消息，消息类型为Map</li>
<li>在控制台查看消息，总结你能发现的问题</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://www.steamedfish.top/tags/rabbitmq/">RabbitMQ</a></li>
      <li><a href="https://www.steamedfish.top/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span><a href="https://www.steamedfish.top/">©2025 SteamedFish&rsquo;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>
<script src="https://unpkg.com/@barba/core"></script>


<script>
window.PaperMod = window.PaperMod || {};
PaperMod.state = { once: false };

PaperMod.initOnce = function () {
  
  if (PaperMod.state.once) return;
  PaperMod.state.once = true;
  console.log("PaperMod initOnce");

  
  if (PaperMod.initAPlayer && !window.__aplayer_inited__) {
    PaperMod.initAPlayer();
  }
};

PaperMod.initPage = function (container = document) {
  console.log("PaperMod initPage");

  PaperMod.initFancybox && PaperMod.initFancybox(container);
  PaperMod.initCodeCopyButtons && PaperMod.initCodeCopyButtons(container);
};


barba.init({
  transitions: [
    {
      name: "default",
      leave() {
        return Promise.resolve();
      },
      enter(data) {
        
        PaperMod.initOnce();
        PaperMod.initPage(data.next.container);
      },
    },
  ],
});



document.addEventListener("DOMContentLoaded", () => {
  PaperMod.initOnce();
  PaperMod.initPage(document);
});

</script>







<link
  href="https://cdn.bootcdn.net/ajax/libs/aplayer/1.10.1/APlayer.min.css"
  rel="stylesheet"
/>
<script src="https://cdn.bootcdn.net/ajax/libs/aplayer/1.10.1/APlayer.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/meting/2.0.2/Meting.min.js"></script>

<meting-js
  server="netease"
  fixed="true"
  lrc-type="1"
  type="playlist"
  id="2245453903"
  api="https://api.qijieya.cn/meting/?type=:type&id=:id"
  >
  
  
         
  
  
  
</meting-js>
<script>
  if (window.Barba) {
    Barba.hooks.afterEnter(function () {
      const metingPlayer = document.querySelector('meting-js');
      if (metingPlayer) {
        metingPlayer.load();  
      }
    });
  }
  
  
  
  
  
  
  

  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  

  
  
  
  

  
  
  
  
  
  
  
  
  
  
  

  
  
  

  
  
  
</script>




<script>
  window.PaperMod = window.PaperMod || {};

  PaperMod.initCodeCopyButtons = function (root = document) {
    root.querySelectorAll("pre > code").forEach((codeblock) => {
      const container = codeblock.parentNode.parentNode;

      
      if (container.querySelector(".copy-code")) return;

      const copybutton = document.createElement("button");
      copybutton.classList.add("copy-code");
      copybutton.innerHTML = '复制';

      function copyingDone() {
        copybutton.innerHTML = '已复制！';
        setTimeout(() => {
          copybutton.innerHTML = '复制';
        }, 2000);
      }

      copybutton.addEventListener("click", (cb) => {
        if ("clipboard" in navigator) {
          navigator.clipboard.writeText(codeblock.textContent);
          copyingDone();
          return;
        }

        const range = document.createRange();
        range.selectNodeContents(codeblock);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        try {
          document.execCommand("copy");
          copyingDone();
        } catch (e) {}
        selection.removeRange(range);
      });
      container.appendChild(copybutton);
    });
  };
</script>


<link rel="stylesheet" href="/lib/fancybox/fancybox.css" />
<script src="/lib/fancybox/fancybox.umd.js"></script>
<script>
  function initFancybox() {
    Fancybox.unbind("[data-fancybox]");

    Fancybox.bind("[data-fancybox]", {
      animated: true,
      showClass: "fancybox-fadeIn",
      hideClass: "fancybox-fadeOut",
      dragToClose: true,
    });
  }

  
  if (document.readyState !== "loading") {
    initFancybox();
  } else {
    document.addEventListener("DOMContentLoaded", initFancybox);
  }
  
  document.addEventListener("barba:afterEnter", initFancybox);
</script>







<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = '复制';

        function copyingDone() {
            copybutton.innerHTML = '已复制！';
            setTimeout(() => {
                copybutton.innerHTML = '复制';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
