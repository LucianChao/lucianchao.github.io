[{"content":"前言 当我们设计了一个类，然后根据这个类又new了一个对象，当这个对象被创建时，内存会为它分配一块空间，当我们创建多个对象时，他们各自占据一块内存\n有些时候，我们并不想new一个对象，而是只是想使用某一个功能\n想统计某个类被创建了多少次，结果发现得在外面数； 想在多个对象之间共享某个数据，比如“总人数”“游戏全局分数”等。 这时，static 关键字就登场了。\n它的意思很简单：属于类，而不是属于对象。\n一、static 是什么？ static 是 Java 中的一个关键字，用来修饰 成员变量、方法、代码块 和 内部类。\n当某个成员被声明为 static 时：\n它不再属于某个对象； 而是被整个类共享； 在内存中只存在一份。 简单来说，就是：\n“类的属性，不用对象也能访问。”\n二、静态变量( static 修饰的变量) 我们先看一个例子：\nclass Student { String name; // 每个学生有自己的名字 static String school = \u0026#34;芭乐高中\u0026#34;; // 所有学生共用同一个学校名 } 使用方式：\npublic class Demo { public static void main(String[] args) { Student s1 = new Student(); s1.name = \u0026#34;汪东城\u0026#34;; Student s2 = new Student(); s2.name = \u0026#34;雷婷\u0026#34;; System.out.println(s1.name + \u0026#34; - \u0026#34; + s1.school); System.out.println(s2.name + \u0026#34; - \u0026#34; + s2.school); } } 输出结果：\n汪东城 - 芭乐高中 雷婷 - 芭乐高中 如果修改 school：\nStudent.school = \u0026#34;热血高校\u0026#34;; 再打印，你会发现所有对象看到的学校名都变了。\n汪东城 - 热血高校 雷婷 - 热血高校 这说明静态变量是共享的，而非独立的。\n三、静态方法( static 修饰的方法) 静态方法属于类，不依赖于对象。 也就是说，你可以直接用 类名调用，而不是对象名。 比如 Math.sqrt():\npublic class MathDemo { public static void main(String[] args) { double x = 9; double result = Math.sqrt(x); // 调用静态方法sqrt() System.out.println(result); // 输出3.0 } } 你不需要 new Math()，因为 sqrt() 是 static 的。\n这类方法一般具有通用性，与具体对象无关。\n你也可以自己写静态方法：\nclass Tool { public static void printLine() { System.out.println(\u0026#34;----------静态方法运行了----------\u0026#34;); } } 调用：\nTool.printLine(); 输出：\n----------静态方法运行了---------- 四、静态代码块( static 代码块) 静态代码块在类加载时自动执行一次，常用于初始化静态变量。\nclass InitDemo { static int count; static { System.out.println(\u0026#34;静态代码块执行！\u0026#34;); count = 10; } } 运行：\npublic class Test { public static void main(String[] args) { System.out.println(InitDemo.count); } } 输出：\n静态代码块执行！ 10 静态代码块只在类第一次被加载时运行一次，之后不会再执行。 它适合做一些全局初始化的工作。\n五、static 的内存原理 区域 内容 生命周期 栈(Stack) 方法中的局部变量 方法调用时创建，结束时销毁 堆(Heap) 对象和实例变量 使用 new 创建，垃圾回收时销毁 方法区(Method Area) 类信息、静态变量、常量 程序运行期间始终存在 static 成员就存放在方法区中，它随着类加载时一起被加载到方法区中\n因此，不论你创建多少个对象，它都只有一份拷贝。\n六、static 的注意事项 静态方法不能直接访问非静态成员。\nclass Demo { int a = 10; static int b = 20; static void show() { // System.out.println(a); ❌ 报错：不能访问非静态变量 System.out.println(b); // ✅ OK } } 因为静态方法在类加载时就存在，而非静态变量要等对象创建后才存在。\n静态方法中不能使用 this 或 super。\n因为它们属于对象，而 static 属于类。\n尽量避免滥用 static。\n“能用对象解决的，就不要滥用 static。”\n共享数据固然方便，但也会增加耦合和全局状态的复杂度。\n七、经典应用场景 场景 示例 说明 工具类 Math, Arrays, Collections 不需要实例化 常量类 public static final double PI = 3.14159; 定义全局常量 计数器 统计对象创建数量 所有对象共享一个计数器 单例模式 private static 实例 + getInstance() 确保类只有一个实例 八、单例模式(Singleton Pattern) 单例模式（Singleton Pattern）是 Java 中非常经典的设计模式之一。 它的核心思想是：一个类在整个程序运行期间只能有一个对象存在。 这种模式经常用于：\n数据库连接对象 日志系统 配置管理器 游戏中“全局控制器”类等 而 static 正是实现单例模式的关键！\n单例模式分为\u0026quot;懒汉式单例模式\u0026ldquo;和\u0026rdquo;饿汉式单例模式\u0026quot;\n1.饿汉式( Eager Singleton) 饿汉式的特点是：类加载时就创建对象，不管你用不用，它都先准备好。\n优点是线程安全，简单直接；\n缺点是如果对象很大但暂时不用，会造成内存浪费。\nclass EagerSingleton { // 1. 在类加载时就创建唯一实例 private static final EagerSingleton instance = new EagerSingleton(); // 2. 构造函数私有化，防止外部new对象 private EagerSingleton() {} // 3. 提供全局访问点 public static EagerSingleton getInstance() { return instance; } } 使用方式：\npublic class Test { public static void main(String[] args) { EagerSingleton a = EagerSingleton.getInstance(); EagerSingleton b = EagerSingleton.getInstance(); System.out.println(a == b); // 输出 true，说明是同一个对象 } } 输出：\ntrue 2.懒汉式（Lazy Singleton） 懒汉式的特点是：第一次使用时才创建对象。 这样可以节省内存，但要注意线程安全问题。\nclass LazySingleton { private static LazySingleton instance; private LazySingleton() {} public static LazySingleton getInstance() { if (instance == null) { // 第一次调用时才创建对象 instance = new LazySingleton(); } return instance; } } 不过上面这个版本在多线程情况下会有安全问题。 所以更安全的写法是线程安全的懒汉式：\nclass SafeLazySingleton { private static SafeLazySingleton instance; private SafeLazySingleton() {} public static synchronized SafeLazySingleton getInstance() { if (instance == null) { instance = new SafeLazySingleton(); } return instance; } } 3.静态内部类式（推荐写法） 这是一种综合了“饿汉式的线程安全”和“懒汉式的延迟加载”的写法。 既安全又高效。\nclass Singleton { private Singleton() {} private static class Holder { private static final Singleton INSTANCE = new Singleton(); } public static Singleton getInstance() { return Holder.INSTANCE; } } 这种写法利用了 Java 的类加载机制：\nHolder 类只有在第一次调用 getInstance() 时才会被加载； 而类加载是线程安全的； 因此不用手动加锁，也不会提前占用内存。 ","permalink":"https://www.steamedfish.top/post/java-se-static/","summary":"\u003ch1 id=\"前言\"\u003e前言\u003c/h1\u003e\n\u003cp\u003e当我们设计了一个类，然后根据这个类又new了一个对象，当这个对象被创建时，内存会为它分配一块空间，当我们创建多个对象时，他们各自占据一块内存\u003cbr\u003e\n有些时候，我们并不想new一个对象，而是只是想使用某一个功能\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e想统计某个类被创建了多少次，结果发现得在外面数；\u003c/li\u003e\n\u003cli\u003e想在多个对象之间共享某个数据，比如“总人数”“游戏全局分数”等。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这时，\u003ccode\u003estatic\u003c/code\u003e 关键字就登场了。\u003cbr\u003e\n它的意思很简单：\u003cstrong\u003e属于类，而不是属于对象\u003c/strong\u003e。\u003c/p\u003e","title":"Java SE从入门到跑路（五·谁说一定要对象？static登场！）"},{"content":" JAVA——万事万物皆对象 前言 少年，恭喜你！你已经成功打开了新世界的大门！看到这里你的Java学习之路才刚刚开始！从这章起，我们将真正的学习到Java的核心思想，甚至可以说是编程界最伟大的思想之一——面向对象\n前面我们已经学会了使用流程控制、数组和方法，能够让程序按照逻辑顺序执行、批量存储数据(数组)、并通过方法复用代码，减少重复劳动。\n但是——你可能也发现了：\n随着程序越来越复杂，变量越来越多，方法也越来越多。\n代码虽然能运行，但看起来杂乱无章，难以维护。 例如：\n你写了一个学生成绩管理程序，学生有姓名、年龄、成绩等信息； 然后你又写了一个老师管理程序，老师也有姓名、工号、科目； 接着你开始写学校的管理逻辑，发现各种变量传来传去，一不小心还会传错。 这时候，你可能会想：\n有没有一种方法，能让数据和操作更自然地绑定在一起， 让程序像我们现实世界一样，有“人”“学生”“老师”这样的对象？\n没错！这就是我们即将要学习的——面向对象编程（Object-Oriented Programming, OOP）。\n什么是对象？ 或许你或多或少听过\n\u0026ldquo;Java是一门面向对象的编程语言\u0026rdquo;\n那什么是对象呢？ 在现实世界中，一切皆为对象： 你是一个对象，我是一个对象，一只狗、一台电脑、一本书，也都是对象。\n每个对象都有自己的属性（是什么）和行为（能做什么）。\n举个例子：\n对象 属性 行为 学生 姓名、年龄、成绩 学习、考试、玩游戏 狗 品种、颜色、体重 吠叫、奔跑、吃饭 电脑 品牌、CPU、内存 运行程序、播放音乐、联网 在编程的世界里，我们用类（class）来描述这些对象的“模板”， 再用对象（object）来表示具体的实例。\n你可以把“类”理解为图纸，而“对象”就是根据这张图纸造出的产品。\n为什么要面向对象？ 面向对象编程（OOP）的核心思想是：\n用“对象”的方式去模拟真实世界，从而让代码更加自然、清晰、可维护。 他让我们：\n把数据和行为绑定在一起（更符合人的思维习惯）； 让大型程序可以模块化，彼此独立、互不干扰； 让代码更容易扩展和复用。 类与对象(Class \u0026amp; Object) 1.类的定义 类（Class）可以看作是一类事物的模板或设计图。\n在 Java 中定义一个类的基本语法是这样的：\nclass 类名 { // 成员变量（属性） // 成员方法（行为） } 举个例子，我们定义一个学生类： 学生都有：\n姓名（name） 年龄（age） 这些共同特征就可以抽象成一个类：\nclass Student { String name; // 学生姓名 int age; // 学生年龄 void study() { System.out.println(name + \u0026#34; 正在学习 Java！\u0026#34;); } } 这里的 Student 就是一个类，它描述了“学生”这个概念中共同的属性。 在这个类中：\nname 和 age 是 属性（成员变量）； study() 是 方法（行为）。 2.对象的创建与使用 对象（Object）是根据类创建出来的具体实例。\n类就像“图纸”，对象就是“根据图纸造出来的东西”。\n对象的创建 创建对象的语法是：\n类名 对象名 = new 类名(); 比如：\npublic class Test { public static void main(String[] args) { Student s1 = new Student(); // 创建对象 s1.name = \u0026#34;小明\u0026#34;; s1.age = 18; s1.study(); // 调用方法 } } 输出：\n小明 正在学习 Java！ 这就是最基础的类与对象的使用。 每一个 new 都会在内存中创建一个新的独立对象。\n多个对象与内存独立性 当你写下：\nStudent s = new Student(); 内存中发生了以下事情：\n在堆内存(Heap) 中分配空间存储对象的数据；\n在栈内存(Stack) 中保存对象的引用（地址）；\n当对象不再被引用时，Java 的垃圾回收机制(GC) 会自动回收它。\n所以：\n当我们只创建一个对象并重复引用它：\nStudent s1 = new Student(); Student s2 = s1; //s1创建了一个新对象并引用它 //把s1的引用赋值给s2 //s2和s1引用着同一个对象 此时 s1 和 s2 指向同一个对象，修改其中一个，另一个也会变。\n当我们创建多个对象时，它们之间是相互独立的。\nStudent s1 = new Student(); s1.name = \u0026#34;小明\u0026#34;; Student s2 = new Student(); s2.name = \u0026#34;小红\u0026#34;; s1.study(); // 输出：小明 正在学习 Java！ s2.study(); // 输出：小红 正在学习 Java！ 在上面的示例中，s1 就是一个“学生对象”，它拥有独立的数据空间。 如果再创建一个 s2，两个对象各自拥有自己的 name，互不干扰。 它们就像两台独立运行的电脑，拥有自己的内存空间。\n构造方法(Constructor) 有时候我们希望在创建对象的同时就给它赋值，这就要用到构造方法。\n构造方法是用来创建对象时进行初始化的特殊方法。\n1.构造方法的特点 方法名必须和类名相同； 没有返回值类型； 可以带参数，也可以不带参数。 2.构造方法的概念 它的名字必须和类名相同，且没有返回类型。\npublic class Student { String name; int age; // 构造方法 public Student(String n, int a) { name = n; age = a; } void showInfo() { System.out.println(\u0026#34;姓名：\u0026#34; + name + \u0026#34;，年龄：\u0026#34; + age); } } 创建对象时会自动调用构造方法\n示例：\npublic class Test { public static void main(String[] args) { Student s = new Student(\u0026#34;小明\u0026#34;, 18); s.showInfo(); } } 输出：\n姓名：小明，年龄：18 信息\n如果你不写构造方法，Java 会自动提供一个无参构造方法。\n3.构造方法重载 一个类可以有多个构造方法，只要参数不同：\npublic class Student { String name; int age; public Student() { System.out.println(\u0026#34;无参构造方法被调用\u0026#34;); } public Student(String n, int a) { name = n; age = a; } } 4.this关键字 this 表示当前对象的引用。\n当方法或构造函数中，参数名和成员变量相同时，可以用 this 来区分：\nclass Student { String name; int age; Student(String name, int age) { this.name = name; // this.name 表示成员变量 this.age = age; } } this 表示“当前对象自己”。\n类与对象的实例 看这个示例：\nclass Student { String name; int age; double score; Student(String name, int age, double score) { this.name = name; this.age = age; this.score = score; } void show() { System.out.println(\u0026#34;姓名：\u0026#34; + name + \u0026#34;，年龄：\u0026#34; + age + \u0026#34;，成绩：\u0026#34; + score); } } public class Test { public static void main(String[] args) { Student s1 = new Student(\u0026#34;小明\u0026#34;, 18, 95.5); Student s2 = new Student(\u0026#34;小红\u0026#34;, 17, 88.0); s1.show(); s2.show(); } } 输出：\n姓名：小明，年龄：18，成绩：95.5 姓名：小红，年龄：17，成绩：88.0 思考与练习 写一个 Dog 类，包含属性：name、color、age，并添加方法 bark() 输出 \u0026ldquo;汪汪汪！\u0026rdquo;. 用两种不同方式创建对象（带参和无参构造），打印信息。 思考：如果我在方法里创建一个对象，方法执行结束后，对象还在吗？ 封装(Encapsulation) 刚才我们认识了“类与对象”——学会了怎么创造世界的“事物”。\n但如果你仔细想一想，会发现一个问题：\n我们的对象太“开放”了。\n任何人都能直接修改对象的属性， 假如我们写了一个学生类：\nclass Student { String name; int age; } 别人可以这样使用：\nStudent s = new Student(); s.name = \u0026ldquo;小明\u0026rdquo;; s.age = -10; // ❌ 不合理！ 这对吗？这不对！ 年纪不能是负数！ 显然，不该让外部随意修改内部数据。 我们希望某些数据只能通过特定的方式修改，这就引出了今天的主角：封装（Encapsulation）。\n1.什么是封装？ 简单来说:\n封装就是把对象的属性和实现细节隐藏起来，只暴露出安全的访问方式。\n好比一台电视机：\n外面只有电源键、音量键； 里面的电路你看不到，也不能乱动。 同样的，在程序中，我们通过： private 隐藏属性； public 方法提供控制访问的接口。 2.访问控制修饰符 Java提供了四种访问级别，用来控制“谁能访问什么”：\n修饰符 同类中 同包中 子类中 其他包 public ✅ ✅ ✅ ✅ protected ✅ ✅ ✅ ❌ (默认) ✅ ✅ ❌ ❌ private ✅ ❌ ❌ ❌ 最常用的组合是：\n属性 → private（隐藏数据）\n方法 → public（提供访问入口）\n3.封装的实现方式 来看一个没有封装的类：\nclass Student { String name; int age; } 我们可以直接修改它：\nStudent s = new Student(); s.name = \u0026#34;小明\u0026#34;; s.age = -20; // 不合理！ 这时我们把它改成封装版：\nclass Student { private String name; private int age; // 提供公开的“入口” public void setName(String n) { name = n; } public String getName() { return name; } public void setAge(int a) { if (a \u0026gt; 0 \u0026amp;\u0026amp; a \u0026lt; 120) { age = a; } else { System.out.println(\u0026#34;年龄不合法！\u0026#34;); } } public int getAge() { return age; } } 使用方法：\npublic class Test { public static void main(String[] args) { Student s = new Student(); s.setName(\u0026#34;小明\u0026#34;); s.setAge(-20); // 输出：年龄不合法！ s.setAge(18); System.out.println(s.getName() + \u0026#34; 今年 \u0026#34; + s.getAge() + \u0026#34; 岁\u0026#34;); } } 输出：\n年龄不合法！ 小明 今年 18 岁 4.封装的优点 保证数据安全 不让外部直接篡改敏感数据。 简化使用方式 使用者只需调用方法，不需要关心内部实现。 便于修改维护 内部逻辑可以随时优化，而对外接口保持不变。 举个例子： 以后我们想在 setAge() 里加上 “如果年龄大于18就自动标记成年”， 外部代码完全不用改，只要我们在方法里处理就行。\n5. this的再认识 在封装中，this 通常用来区分成员变量和方法参数。\npublic void setName(String name) { this.name = name; } this.name 表示当前对象的成员变量， 右边的 name 是传入的参数。\n6.构造方法与封装结合 我们可以在构造方法中使用封装的思想：\nclass Student { private String name; private int age; public Student(String name, int age) { setName(name); setAge(age); } // getter / setter 同上 } 这样即使在创建对象时，也会经过合法性检查。\n","permalink":"https://www.steamedfish.top/post/java-se-oop/","summary":"\u003cblockquote\u003e\n\u003ch1 id=\"java万事万物皆对象\"\u003eJAVA——万事万物皆对象\u003c/h1\u003e\n\u003c/blockquote\u003e\n\u003ch1 id=\"前言\"\u003e前言\u003c/h1\u003e\n\u003cp\u003e少年，恭喜你！你已经成功打开了\u003cstrong\u003e新世界的大门\u003c/strong\u003e！看到这里你的Java学习之路才刚刚开始！从这章起，我们将真正的学习到Java的核心思想，甚至可以说是编程界最伟大的思想之一——\u003cstrong\u003e面向对象\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e前面我们已经学会了使用\u003cstrong\u003e流程控制\u003c/strong\u003e、\u003cstrong\u003e数组和方法\u003c/strong\u003e，能够让程序按照逻辑顺序执行、批量存储数据(\u003cstrong\u003e数组\u003c/strong\u003e)、并通过\u003cstrong\u003e方法\u003c/strong\u003e复用代码，减少重复劳动。\u003c/p\u003e","title":"Java SE从入门到跑路（四·面向对象之类与对象篇）"},{"content":"前言 上一章我们学会了流程控制——让程序知道“什么时候做”“做多少次”。 但如果要让程序处理大量数据，比如学生成绩、商品价格、坐标点列表，你会发现：\n光靠一个个变量，代码又臭又长、又难维护。\n比如计算三个学生的平均分，你可能会写出这样的代码：\nint a = 90, b = 80, c = 70; int sum = a + b + c; double avg = sum / 3.0; System.out.println(\u0026#34;平均分：\u0026#34; + avg); 要是有十个学生呢？一百个呢？ 这时我们就需要一个能一次性装下多个数据的“容器”——数组(Array)。 以及一个能封装、复用代码逻辑的工具——方法(Method)。\n数组(Array) 1.数组的概念 数组是存放同一类型数据的有序集合。\n同一类型：数组里只能放整数、浮点数、字符串等同一种类型。 有序集合：每个元素都有自己的位置（下标）。 可以把它想象成一个带编号的格子柜，每个格子放一个数据，每个格子都有编号（下标）。\n📦 “数组就是一组有序排列的数据箱子。”\n2.为什么要用数组？ 假设你要存10个成绩，不用数组就得写10个变量：\nint s1, s2, s3, s4, s5, s6, s7, s8, s9, s10; 光是声明就够让人崩溃了，更别提算平均数。 数组可以让你用一个变量名表示一组相同类型的数据：\nint[] score = new int[10]; 这行代码就创建了一个能装 10 个整数的“容器”。\n3.数组的声明与创建(Declaration and Creation) 数据类型[] 数组名; // 声明数组 数组名 = new 数据类型[长度]; // 创建数组 示例：\nint[] scores; // 声明一个整数数组 scores = new int[5]; // 创建一个长度为5的数组 或者合并写成一行：\nint[] scores = new int[5]; 信息\n提示：数组长度一旦创建就固定，不能动态改变。 如果要动态扩展，得使用“容器类”（比如 ArrayList），后面我们会讲。\n4.数组的初始化(Initialization) 数组创建出来之后，还需要“放东西进去”——这就是初始化。\nJava中有三种常见方式：\n静态初始化 适用于：已知每个元素时使用\n格式 数据类型[] 数组名 = {元素1,元素2,元素3...}; //必须在一个语句中完成，不能分开两个语句写 示例 int[] scores = {90, 80, 70, 85, 95}; 动态初始化 适用于：先确定长度，稍后再赋值。\n格式： 数据类型[] 数组名 = new 数据类型[长度]; 数组名[下标] = 值; 示例 int[] scores = new int[5];//创建一个长度为5的整形数组，五个元素的下标为 0, 1, 2, 3, 4 scores[0] = 90; //下标为0的元素值为90 scores[1] = 80; //下标为1的元素值为80 scores[2] = 70; //下标为2的元素值为70 scores[3] = 85; //下标为3的元素值为85 scores[4] = 95; //下标为4的元素值为95 信息\n注意： 数组下标从0开始，最后一个下标是 长度- 1\n访问越界会导致 报错Array(数组)Index(索引)OutOfBounds(越界)Exception(异常)\n混合写法 其实静态初始化和动态初始化也能结合\nint[] scores = new int[]{90, 80, 70, 85, 95}; 不过这种方式在现代Java中较少使用。\n5.数组元素的默认值(Hybrid Initialization) 当你用 new 创建一个数组时，Java 会自动为每个元素赋初始值：\n数据类型 默认值 byte, short, int, long 0 float, double 0.0 char '\\u0000'（空字符） boolean false 引用类型（对象） null 示例：\nint[] nums = new int[3]; //初始化一个整形数组 //不手动为元素赋值，整形数组的元素默认值为0 System.out.println(nums[0]); // 输出 0 6.数组的遍历和访问(Access and Traverse) 前面提过，数组中的每个元素都有自己的编号，叫下标（index），从 0 开始。\n例如：\nint[] nums = {10, 20, 30, 40, 50}; 它的下标与值的关系是这样的：\n下标 值 0 10 1 20 2 30 3 40 4 50 使用下标访问： 要访问第三个元素\nSystem.out.println(nums[2]); // 输出30 // 输出下标为2的元素 如果我们要把第一个元素从10改成99呢？\nnums[1] = 99; // 把第二个元素改为99 使用for循环访问： 数组遍历是指依次访问每个元素。最常见的是 for 循环：\nint[] nums = {10, 20, 30, 40, 50}; for (int i = 0; i \u0026lt; nums.length; i++) { System.out.println(nums[i]); } 输出结果：\n10 20 30 40 50 信息\n⚠️ 注意： length 是属性（没有括号），而不是方法。 不要写成 scores.length()。\n使用增强for循环(for-each) 如果只是读取数组内容，不修改，可以使用更简洁的写法：\nfor (int s : nums) { System.out.println(s); } 输出结果：\n10 20 30 40 50 这表示“依次把数组 nums 的每个元素赋值给变量 n”。 但是要注意：\n增强型 for 不能修改数组的内容，因为 n 是副本。\n信息\n这里觉得吃力也没关系，看不懂很正常，后面会深入了解的\n7.数组的长度和属性(Array Length) 数组是一个对象\n注释\n又听的云里雾里了吧，一直说对象，数组也是对象，对象到底是啥啊？\n依旧别急，航母下海前，你得先造零件，后面再学，现在先打基础\n数组对象自带length属性来表示它的长度\nSystem.out.println(\u0026#34;数组长度：\u0026#34; + scores.length); 8.二维数组(2D Arrays) 数组中还能存数组，这就是“二维数组”：\nint[][] matrix = { {1, 2, 3}, {4, 5, 6}, {7, 8, 9} }; 访问方式：\nSystem.out.println(matrix[0][1]); // 输出第1行第2列的元素 2 二维数组常用于存储表格、棋盘等数据结构。\n9.数组的应用实例 查找最大值 int[] arr = {3, 5, 7, 2, 9}; int max = arr[0]; for (int i = 1; i \u0026lt; arr.length; i++) \u0026gt;{ if (arr[i] \u0026gt; max) { max = arr[i]; } } System.out.println(\u0026#34;最大值：\u0026#34; + max); 数组反转 上强度了喔\nint[] arr = {1, 2, 3, 4, 5}; for (int i = 0; i \u0026lt; arr.length / 2; i++) { int temp = arr[i]; arr[i] = arr[arr.length - 1 - i]; arr[arr.length - 1 - i] = temp; } System.out.println(Arrays.toString\u0026gt;(arr)); // [5, 4, 3, 2, 1] 思考题 要你写一个完整的程序，要有输入输出，利用循环和数组计算5个学生的平均成绩，你会怎么做？\n试着自己写写看\n最近比较忙，目前还没时间搞一下博客的基础功能 不过有打算加入评论区了，在评论区上线之前 如果你有我的联系方式可以私信我讨论🙂\n方法(Method) 数组让我们高效管理数据， 方法则让我们高效复用逻辑。\n1.方法的概念 方法是可以被重复调用的代码块，用来完成特定功能。 就像现实中“函数”或“工具”：\n写一次，用多次。\n例如，计算两个数的和：\nint sum = a + b; 如果你需要多次计算不同的加法，就可以写成方法：\npublic static int add(int a, int b) { return a + b; } 然后在 main()(程序入口/main函数) 里直接调用：\nint result = add(3, 5); System.out.println(result); // 输出8 2.方法的定义格式 修饰符 返回类型 方法名(参数列表) { // 方法体 return 返回值; } 修饰符：一般先写 public static\n返回类型：方法返回的数据类型（无返回值写 void）\n方法名：遵循小驼峰命名，如 getSum\n参数列表：要传入的变量（可有多个）\nreturn：返回一个结果\n3.方法的调用 在同一个类中:\npublic static void main(String[] args) {//主程序 sayHello(); // 调用方法 } //程序结束 public static void sayHello() { System.out.println(\u0026#34;Hello Java!\u0026#34;); } 4.有参和无参方法 无参方法 public static void printLine() { System.out.println(\u0026#34;===========\u0026#34;); } 调用:\nprintLine(); 有参方法 public static void printSum(int a, int b) { System.out.println(\u0026#34;和为：\u0026#34; + (a + b)); } 调用：\nprintSum(10, 20); 输出:\n=========== 5.带返回值的方法 public static int getMax(int a, int b) { if (a \u0026gt; b) return a; else return b; } 调用：\nint max = getMax(3, 8); System.out.println(\u0026#34;最大值：\u0026#34; + max); 输出:\n8 6.方法和数组结合 方法也能处理数组，非常常见\n只要把数组当作参数传入一个可以接受数组的方法即可：\npublic static int getSum(int[] arr) { int sum = 0; for (int n : arr) { sum += n; } return sum; } 调用\nint[] nums = {1, 2, 3, 4, 5}; System.out.println(getSum(nums)); // 输出15 输出:\n15 可变参数和方法重载 1.可变参数(Varargs) 在前面的例子中，我们定义的方法参数个数是固定的\n例如：\npublic static int add(int a, int b) { return a + b; } 但如果我们想计算 任意多个数的和，\n比如：\nadd(1, 2); add(1, 2, 3); add(5, 10, 15, 20); 就没法写一个固定参数的方法了。\n这时我们就可以使用 可变参数（Variable Arguments）。\n2.可变参数的定义 修饰符 返回类型 方法名(参数类型... 参数名) { } 重点是参数类型后的 \u0026hellip;\n实例：\npublic static int sum(int... nums) { int sum = 0; for (int n : nums) { sum += n; } return sum; } 调用：\nSystem.out.println(sum(1, 2)); // 输出3 System.out.println(sum(1, 2, 3)); // 输出6 System.out.println(sum(5, 10, 15, 20)); // 输出50 3.可变参数的本质 可变参数本质上就是一个数组。 上面的 int... nums 在方法内部等价于：\nint[] nums; 也就是说：\nsum(1, 2, 3); 会被 Java 自动转换成：\nsum(new int[]{1, 2, 3}); 信息\n可变参数在一个方法中只能有一个，\n并且必须是参数列表的最后一个参数。\n4.方法重载 方法重载 是指在同一个类中，允许多个方法 名字相同，但 参数不同（数量、类型或顺序不同）。\n示例：\npublic static int add(int a, int b) \u0026gt;{ return a + b; } public static double add(double a, double b) { return a + b; } public static int add(int a, int b, int c) { return a + b + c; } 调用：\nSystem.out.println(add(1, 2)); // 调用第一个方法 System.out.println(add(1.5, 2.5)); // 调用第二个方法 System.out.println(add(1, 2, 3)); // 调用第三个方法 输出：\n3 4.0 6 5.方法重载的匹配规则 当 Java 编译器看到多个同名方法时，会根据参数类型和数量自动匹配最合适的版本。\n优先级顺序为：\n精确匹配（参数类型完全一致）\n自动类型提升（如 int → double）\n可变参数匹配（最后兜底） 例如：\npublic static void show(int a) { System.out.println(\u0026#34;int\u0026#34;); } public static void show(double a) { System.out.println(\u0026#34;double\u0026#34;); } public static void show(int... a) { System.out.println(\u0026#34;varargs\u0026#34;); } show(10); // 输出 int（精确匹配） show(10.5); // 输出 double show(); // 输出 varargs（没有参数时调用） 6.方法重载的优点 语义统一：相同功能用一个名字即可，逻辑更清晰。 灵活易用：可处理不同类型或数量的输入。 提高代码可读性 综合应用实例 计算任意学生的成绩的平均值\npublic class ScoreTool { public static double avg(int... scores) { int sum = 0; for (int s : scores) sum += s; return (double) sum / scores.length; } public static double avg(double... scores) { double sum = 0; for (double s : scores) sum += s; return sum / scores.length; } public static void main(String[] args) { System.out.println(avg(80, 90, 100)); // int 版本 System.out.println(avg(88.5, 92.0, 76.5)); // double 版本 } } 输出：\n90.0 85.66666666666667 思考题\n编写一个方法 max(int... nums)，返回任意多个整数中的最大值。\n编写一个方法 printArr(int[] arr)，按 [1, 2, 3, 4] 格式打印数组内容。\n编写一个重载方法 sayHello()：\n无参时输出“Hello Java”；\n有一个 String name 参数时输出“Hello + name”。\n","permalink":"https://www.steamedfish.top/post/java-se-arrays-methods/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e上一章我们学会了\u003cstrong\u003e流程控制\u003c/strong\u003e——让程序知道“什么时候做”“做多少次”。   \u003cbr\u003e\n但如果要让程序处理大量数据，比如学生成绩、商品价格、坐标点列表，你会发现：\u003cbr\u003e\n光靠一个个变量，代码又臭又长、又难维护。\u003cbr\u003e\n比如计算三个学生的平均分，你可能会写出这样的代码：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-java\" data-lang=\"java\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e90\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e80\u003c/span\u003e\u003cspan class=\"p\"\u003e,\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e70\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003eint\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003esum\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ea\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eb\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003ec\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"kt\"\u003edouble\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eavg\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003esum\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e/\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003e3\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003e0\u003c/span\u003e\u003cspan class=\"p\"\u003e;\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"w\"\u003e\u003c/span\u003e\u003cspan class=\"n\"\u003eSystem\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eout\u003c/span\u003e\u003cspan class=\"p\"\u003e.\u003c/span\u003e\u003cspan class=\"na\"\u003eprintln\u003c/span\u003e\u003cspan class=\"p\"\u003e(\u003c/span\u003e\u003cspan class=\"s\"\u003e\u0026#34;平均分：\u0026#34;\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"o\"\u003e+\u003c/span\u003e\u003cspan class=\"w\"\u003e \u003c/span\u003e\u003cspan class=\"n\"\u003eavg\u003c/span\u003e\u003cspan class=\"p\"\u003e);\u003c/span\u003e\u003cspan class=\"w\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e要是有十个学生呢？一百个呢？ \u003cbr\u003e\n这时我们就需要一个能一次性装下多个数据的“容器”——\u003cstrong\u003e数组(Array)\u003c/strong\u003e。  \u003cbr\u003e\n以及一个能封装、复用代码逻辑的工具——\u003cstrong\u003e方法(Method)\u003c/strong\u003e。\u003c/p\u003e","title":"Java SE从入门到跑路（三·数组与方法篇）"},{"content":"前言 在正式开始写代码之前，我们先聊一个非常重要的概念——程序的结构（Program Structures）。 很多新手一上来就盯着语法，看得眼花缭乱，但其实理解程序的“骨架”比死记硬背语法更重要。\nThink of it as building a house 你可以买很贵的材料，但没有合理的框架，房子也盖不稳。\n程序的基本结构主要有三种：顺序结构（Sequential Structure）、分支结构（Branching Structure）、循环结构（Looping Structure）。\n掌握了这三种结构就能实现程序的流程控制\n流程控制就是告诉计算机：\n什么时候做，做多少次，做完怎么办”\n掌握了流程控制，才能写出有逻辑、能做决策和重复操作的程序。\n程序结构概览（Program Structures Overview） 在计算机的世界里，所有的程序无论多复杂，其实都可以由这三种基本结构组合而成：\n顺序结构（Sequential Structure）：语句从上到下依次执行。 分支结构（Branching Structure）：根据条件执行不同的路径。 循环结构（Looping Structure）：让某些语句重复执行。 这三种结构看似简单，却是所有算法和程序设计的基础。你可以把它们看作是搭建程序逻辑的“三块积木”，复杂的程序都是在这三种结构的基础上堆叠、嵌套而成的。\n顺序结构（Sequential Structure） 顺序结构是程序中最简单、也是最基础的控制方式。\n它遵循“从上往下、依次执行”的原则，每行代码都会被依次执行一次。\n来看一个简单的例子：\nint a = 5; int b = 10; int c = a + b; System.out.println(c); 程序会先执行第一行，再执行第二行，然后是第三行，最后输出结果 15。\n再看这个例子：\nint a = 5; int b = 10; System.out.println(c); int c = a + b; 如果我们交换语句的顺序，比如在给 c 赋值之前就打印 c，程序就会报错，因为 c 还不存在。\n信息\n💬 小知识：输入与输出（Input / Output）\n在java中，我们通常用以下两种方式与控制台交互：\nScanner sc = new Scanner(System.in); // 创建输入对象，用于接收键盘输入 System.out.println(\u0026#34;请输入一个数字：\u0026#34;); // 输出提示信息 int a = sc.nextInt(); // 从控制台读取一个整数 System.out.println(\u0026#34;你输入的是：\u0026#34; + a); System.out.println() 用于输出信息到屏幕； Scanner 则用来接收用户输入。\n顺序结构实例 接下来我们就用上刚学到的输入与输出来写一个经典的顺序结构程序\n求两个数平均值:\nimport java.util.Scanner; //导包，后面学 public class Average { //定义类，后面学 public static void main(String[] args) { //程序入口 Scanner sc = new Scanner(System.in); //创建一个扫描器对象用来接受键盘输入 System.out.print(\u0026#34;请输入两个整数：\u0026#34;); //打印提示信息 int a = sc.nextInt(); //从键盘读取一个整数赋值给a int b = sc.nextInt(); //读取一个整数赋值给b double avg = (a + b) / 2.0; //定义一个浮点数(小数)avg，把a+b/2的值赋给它 System.out.println(\u0026#34;平均值是：\u0026#34; + avg); //打印avg } } 分支结构(Branching Structure) 有时候程序需要根据条件选择不同的路径执行，比如“如果成绩大于60就及格，否则不及格”。 这时候我们就要用到分支结构。\n1. if语句 if语句的语法格式 格式1：单分支结构\n当条件表达式为true，则执行语句体\nif(条件表达式){ 语句体; } 格式2：双分支结构\n当条件表达式为true，则执行语句体1，否则执行语句体2\nif(条件表达式){ 语句体1; }else{ 语句体2; } 格式3：多分支结构\n当条件表达式1为true，则执行语句体1\n当条件表达式2为true，则执行语句体2 当条件表达式3为true，则执行语句体3 \u0026hellip; 当以上条件都为false，则执行语句体n+1\nif(条件表达式1){ 语句体1; }else if(条件表达式2){ 语句体2; }else if(条件表达式3){ 语句体3; } ... else{ 语句体n+1; } 提示\nif语句可以与其他语句进行嵌套 如：\nif(条件表达式1){ if(条件表达式2){ 语句体2; }else{ 语句体3; } }else{ 语句体1; } 当条件表达式1为true，则进入嵌套判断条件表达式2 当条件表达式2为true，则执行语句体2,否则执行语句体3\n当条件表达式1为false，则执行语句体1\n2. switch语句 上面的if...else、if...else 与if...else...if都是多分支结构\nswitch语句也是多分支结构的一种，当一个变量可能有多种确定取值时，switch 语句比 if...else 更直观和简洁。 比如菜单选择、星期判断、等级判断等场景，就非常适合用 switch。\nswitch语句的语法格式 switch(表达式){ case 常量1: 语句体1; break; case 常量2: 语句体2; break; ... default: 语句体n+1; break; } switch语句的执行流程：\n先计算表达式的值 与每个case的常量进行比较 如果匹配成功则执行对应的语句体 若遇到break，则跳出整个switch语句 如果所有case都不匹配，则执行default switch语句的\u0026quot;穿透\u0026quot;问题 上面我们说到：\n若遇到break，则跳出整个switch语句\n如果没有遇到break呢? 我们以下面这段程序举例：\nint day = 3; switch (day) { case 1: System.out.println(\u0026#34;星期一\u0026#34;); break; case 2: System.out.println(\u0026#34;星期二\u0026#34;); break; case 3: System.out.println(\u0026#34;星期三\u0026#34;); //没有break case 4: System.out.println(\u0026#34;星期四\u0026#34;); //没有break default: System.out.println(\u0026#34;未知日期\u0026#34;); break; } 上面这段程序的输出为：\n星期三 星期四 未知日期 我们对它的匹配过程进行分析：\ncase 1: 不匹配，因为 day 是 3。 case 2: 不匹配，因为 day 仍然是 3。 case 3: 匹配成功，执行 System.out.println(\u0026quot;星期三\u0026quot;);，输出 星期三。 注意：由于没有 break 语句，控制流将继续执行下一个 case。 case 4: 也会被执行，输出 星期四。 由于没有匹配到 case 5，控制流继续到 default:，输出 未知日期。\n提示\n每个 case 后面通常需要 break 语句，以防止遇到switch语句的穿透问题。\n循环结构(Looping Structure) 在很多程序中，我们会遇到重复执行同一段代码的情况。 比如：\n打印 1 到 10 的数字\n求数组中所有元素的总和\n让用户不断输入直到满足某个条件\n如果每次都手动写重复代码，既麻烦又容易出错，这时就需要循环结构（Looping Structure）。\n1. while循环 while 循环先判断条件，如果条件为 true，就执行循环体；循环体执行完，再判断条件，如此重复，直到条件为 false。\nwhile循环的语法格式 初始化语句; while(循环条件){ 循环体语句(被重复执行的代码) 迭代语句; } while循环的示例 打印 1 - 5\nint i = 1; while (i \u0026lt;= 5) { System.out.println(\u0026#34;i = \u0026#34; + i); i++; // 不加 i++ 会无限循环 } 输出结果：\ni = 1 i = 2 i = 3 i = 4 i = 5 2. do\u0026hellip;while循环 do...while 循环和 while 类似，但它先执行一次循环体，再判断条件。 即使条件一开始为 false，循环体也会至少执行一次。\ndo\u0026hellip;while循环的语法格式 初始化语句 do{ 循环体语句; 迭代语句; }while(循环条件); do\u0026hellip;while循环的示例 int i = 6; do { //先执行一遍do{}循环体 System.out.println(\u0026#34;i = \u0026#34; + i); //输出i i++; //i自增1 } while (i \u0026lt;= 5); //i=7，判断i是否\u0026lt;=5，结果为false，结束循环 输出结果：\ni = 6 3. for循环 for 循环是最常用的循环形式，尤其在已知循环次数时。\nfor循环的的语法格式 for (初始化 ; 条件表达式 ; 步进(迭代语句)){ 循环体; } for循环的示例 打印 1 - 5\nfor (int i = 1; i \u0026lt;= 5; i++) { System.out.println(\u0026#34;i = \u0026#34; + i); } 输出结果：\ni = 1 i = 2 i = 3 i = 4 i = 5 关键字break和continue 1. break break：直接结束循环\nfor (int i = 1; i \u0026lt;= 5; i++) { if (i == 3) break; System.out.println(i); } 输出结果：\n1 2 //在i=3时，break被执行，跳出当前循环 2. continue continue：跳过本次循环\nfor (int i = 1; i \u0026lt;= 5; i++) { if (i == 3) continue; System.out.println(i); } 输出结果：\n1 2 4 //在i=3时，continue被执行，跳过本次循环 5 break和continue的区别 关键字 作用 是否结束循环 典型用途 break 直接跳出循环 ✅ 是 提前退出循环 continue 跳过当前循环 ❌ 否 跳过不需要处理的情况 作用域(Scope) 作用域是指变量能够被访问到的范围。\n理解它非常重要，因为变量只在它被定义的代码块 { } 内有效。\n类型 定义位置 作用范围 生命周期 成员变量 类中 整个类 对象存在时 局部变量 方法/语句块中 当前 {} 内 执行完代码块后销毁 局部变量的作用域 局部变量：定义在方法或代码块中，只能在当前块内使用 示例1：\nif (true) { int a = 10; System.out.println(a); // ✅ 可以访问 } // System.out.println(a); // ❌ 报错：a 无法访问 a 变量定义在 if 的大括号{}里，所以离开这个大括号后，它就“消失”了。\n示例2：\nfor (int i = 0; i \u0026lt; 3; i++) { System.out.println(i); } // System.out.println(i); // ❌ 报错：i 在这里无效 变量 i 只在 for 循环的 {}中存在。\n成员变量的作用域 成员变量 又称 全局变量 、 类变量 ：定义在类中，方法外，可以被整个类的所有方法访问 示例： public class Demo { int x = 10; // 成员变量（全局） public void test() { //类中的一个方法，方法名为 test int y = 5; // 局部变量 System.out.println(x + y); // ✅ 都能访问 } } ","permalink":"https://www.steamedfish.top/post/java-se-control-flow/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e在正式开始写代码之前，我们先聊一个非常重要的概念——程序的结构（Program Structures）。 \u003cbr\u003e\n很多新手一上来就盯着语法，看得眼花缭乱，但其实理解程序的“骨架”比死记硬背语法更重要。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003eThink of it as building a house \u003cbr\u003e\n你可以买很贵的材料，但没有合理的框架，房子也盖不稳。\u003c/p\u003e","title":"Java SE从入门到跑路（二·流程控制篇）"},{"content":"前言 本文作为JavaSE系列的第一篇文章，我会尽可能的解释一些基础知识和常用的编辑器（本文统一使用 IDEA ）操作并附上图片说明，但本文过后我将不再过多赘述，若有读者遇见不懂的难题，可以翻看本篇文章或自行查阅相关资料。\n关于我的系统环境以及Java、JavaSE、SDK、JVM是什么？等等问题，后面可能会出一篇《JavaSE前置篇》来进行说明，但目前没有这个打算，因为一开始想写这个系列，也仅仅是想对之前学习的一些知识进行一个归纳和总结。 或许写完JavaSE系列后可能会抽出空来进行补充。\n接下来就让我们开始吧！\n注释(Comment) 1.什么是注释？ 注释是写在源代码中的说明性文字，用于解释程序的功能或逻辑，不参与程序运行。\n2.有什么作用？ “能看懂自己程序的，只有上帝和写程序时的自己。”\n为了提高代码的可读性并让代码便于维护，注释是十分必要的，有一个良好的注释习惯有如下好处：\n提高代码可读性与可维护性 帮助团队协作、快速理解代码意图 方便后期调试与文档生成 3.注释的种类 注释分为三种\n单行注释 单行注释：//\n单行注释的快捷键：Ctrl + /\n//这是一行注释 多行注释 多行注释以 /* 开头，以 */ 结尾\n多行注释的快捷键：Ctrl+Shift+/\n/* 第一行注释 第二行注释 */ 文档注释 文档注释以/**开头，以*/结尾。 注释内容可以被JDK提供的工具javadoc所解析，生成一套以网页文件形式（.html）体现的该程序的说明文档，只放在类、接口、成员变量、方法之前（因为Javadoc只处理这些地方的文档注释，而忽略其他地方的文档注释）\n/** * 这是一个文档注释 * 可用于生成API文档 */ 注释\n文档注释有固定格式，在实际开发中使用频率较高。后续我会专门写一篇介绍 Javadoc 的文章。\n4.注释的特点 它不会影响程序的执行，在程序编译时，会忽略掉注释，编译后的class文件中不会有注释\n字面量(Literal) 1.什么是字面量？ 字面量就是在程序中直接写出来的固定值，它代表了程序中某个具体的数据内容。\n简单来说，字面量就是数据本身。\n2.字面量的分类 在Java中，字面量根据数据类型的不同可以分为以下几类\n数据类型 举例 说明 整数 10,-5,0 没有小数的整数值 小数 3.14,-0.5,2.0 带小数点的数值 字符 'A','中','9' 用单引号括起来的单个字符 字符串 \u0026quot;Hello\u0026quot;,\u0026quot;你好\u0026quot; 用双引号括起来的一串字符 布尔值 true,false 表示逻辑真假 空值 null 表示“空”或“无引用” 一些特殊值 \\n,\\t,\u0026hellip; 分别表示换行符和制表符，这里只挑选了两个常见的特殊值 3.字面量的特点 是固定值，不会随程序运行而改变\n可以直接使用，不需要定义变量\n编译器能直接识别字面量的类型\n在内存中会直接以常量的形式存在\n4.实例演示 public class DemoLiteral { public static void main(String[] args) { System.out.println(10); // 整数字面量 System.out.println(3.14); // 浮点数字面量 System.out.println(\u0026#39;A\u0026#39;); // 字符字面量 System.out.println(\u0026#34;Hello\u0026#34;); // 字符串字面量 System.out.println(true); // 布尔字面量 System.out.println(null); // 空字面量 } } 以上程序输出结果如下：\n10 3.14 A Hello true null 一些没有编程基础的同学是不是看着就头大？没关系，我们后面都会学到\n变量 1.什么是变量 变量就是用于存储数据的一块命名的内存空间。\n我们知道，在计算机中，数据是存储在内存中的。\n当我们创建一个变量时，系统会在内存中分配一块空间来存放数据，同时我们为这块空间起一个名字（变量名）， 这样就可以通过这个名字来访问或修改存储在其中的数据。\n打个比方，它就像一个贴了标签(变量名)的盒子，我们可以把数据放进去，当我们需要对它进行操作的时候，可以根据它的标签找到它，然后对它进行操作(访问或者修改)\n2.变量的定义格式 在Java中，变量的定义格式是：数据类型 变量名 = 值\n例如：\nint age = 18; //定义一个整数18，变量名为age //定义一个名为age的整数，值为 18 double score = 95.5; //定义一个名为score的小数，值为 95.5 String name = \u0026#34;Tom\u0026#34;; //定义一个名为name的字符串，值为 Tom 3.变量的意义 如果没有变量，我们每次操作数据都得直接写数字或字符串，非常不方便。\n例如：当我们想要输出一个数字乘以10的结果\nSystem.out.println(10 * 10); //输出10×10的结果 System.out.println(20 * 10); //输出20×10的结果 我们每次想换一个数的时候，都得重新改动一下代码 而使用变量后，只需要改一处：\nint x = 10; //定义一个变量x，值为10 System.out.println(x * 10); //计算x乘10的结果 //当我们想计算20乘以10的值时，只需要修改x就可以 x = 20; System.out.println(x * 10); 有人要说了\n这不对吧老师，用了变量不应该更方便吗？怎么还多了两行？敢耍老子\n确实，从“代码行数”上看，好像更长了。 但变量的作用不在于“让代码更短”，而是让程序更灵活、可维护。\n比如：\n要计算多个类似的表达式，也不用一行行去改； 更重要的是，变量可以存储用户输入的值，让程序能处理不同数据，而不是写死在代码里。 让我们举一个更明显的例子\nScanner sc = new Scanner(System.in); //创建一个扫描器对象 System.out.print(\u0026#34;请输入一个数：\u0026#34;); //让用户输入一个数 int x = sc.nextInt(); //把这个数存进x当中 System.out.println(x * 10); //输出x和10相乘的结果 现在，无论用户输入什么数，程序都能自动计算乘以10的结果。\n这就是变量的真正意义：\n让程序“活”起来，能接收不同的数据并进行运算，而不是只能重复执行固定的计算。\n数据类型(Data Type) 在程序中，我们操作的数据并不都是一样的。 有的数字是整数（如 10、100），有的是小数（如 3.14）， 有的表示单个字符（如 \u0026lsquo;A\u0026rsquo;），有的表示一段文字（如 \u0026ldquo;Hello\u0026rdquo;）， 还有的表示真假（true / false）。\n这些不同“种类”的数据，就需要用不同的数据类型(Data Type) 来表示。\n在 Java 中，每个变量都必须有数据类型。数据类型决定了变量可以存储什么样的数据，以及占用多少内存空间。\n通俗地说，数据类型就是告诉计算机：我要存的是什么样的数据、需要多大的空间。\n1.数据类型的分类 Java 是一种强类型语言，也就是说， 每一个变量在使用前，必须先声明它的类型。 这保证了程序的安全性和可预测性。\nJava 的数据类型分为两大类👇：\n分类 类型名称 说明 基本数据类型(Primitive Type) byte,short,int,long,float,double,char,boolean 用于存放最基本的值，比如数字、字符、真假等 引用数据类型(Reference Type) 类 (Class)、接口(Interface)、数组(Array)等 用于存放对象、数组等复杂数据 2.基本数据类型 基本类型可以分为数值类型和非数值类型两种\n基本数据类型 数值类型 整数类型 ^ ^ 浮点类型 ^ 非数值类型 字符类型 ^ ^ 布尔类型 整数类型 基本数据类型 类型 占用字节 取值范围 整数类型 byte 1 -128 ~ 127 ^ short 2 -32,768 ~ 32,767 ^ int 4 -2³¹ ~ 2³¹-1 ^ long 8 -2⁶³ ~ 2⁶³-1 浮点类型 基本数据类型 类型 占用字节 取值范围 描述 浮点类型 float 4 小数（约7位有效数字） 单精度浮点数 ^ double 8 小数（约15位有效数字） 双精度浮点数(默认) 字符类型 基本数据类型 类型 占用字节 取值范围 字符类型 char 2 单个字符，使用单引号表示 布尔类型 基本数据类型 类型 占用字节 取值范围 字符类型 boolean 1 只能存储 true 或 false 3.引用数据类型 除了基本数据类型，Java 还有引用类型，用来存储对象的地址。常见的引用类型有：\nString：字符串\n数组：int[] nums = {1, 2, 3};\n自定义类类型：Student s = new Student();\n示例：\nString name = \u0026#34;小明\u0026#34;; int[] scores = {90, 85, 78}; Student stu = new Student(); 引用类型存储的是对象在内存中的地址，而不是对象本身。\n4.数据类型的选择 尽量使用合适的数据类型，既节省内存又保证精度。\n例如存年龄用 byte 就足够，不必用 int。\n浮点数计算尽量用 double，精度更高。\n布尔类型用于逻辑判断，提高代码可读性。\n类型转换 在 Java 中，类型转换是指将一种数据类型的值转换成另一种数据类型的值。 类型转换可以让程序更加灵活，但使用不当也容易出错。\n1.自动类型转换(隐式转换) 当 小范围类型赋值给 大范围类型时，Java 会自动进行类型转换，这种转换称为自动类型转换（或隐式转换）。\n规则：\n数据范围小 -\u0026gt; 数据范围大 例如：byte → short → int → long → float → double 示例： int i = 100; //定义一个int变量，命名为i double d = i; //定义一个double变量，值为i的值， //i的值是一个整形(整数类型)100, //int 自动转换为 double System.out.println(d); // 输出 100.0 //因为d为double类型(双精度浮点数/小数) //所以这里输出的是100.0而不是100 2.强制类型转换(显式转换) 当 大范围类型赋值给 小范围类型时，必须进行强制类型转换，否则编译报错。\n这种转换称为强制类型转换（或显式转换）。\n强转的语法：\n目标类型 变量名 = (目标类型) 值; 示例：\ndouble d = 9.78; //定义一个小数d，值为9.78 int i = (int) d; //将小数d强制转换为int类型(整形/整数类型)i // 强制转换 double → int System.out.println(i); // 输出i得到 9（小数部分被截断） 注意：强制类型转换可能会导致精度丢失或数据溢出，需要谨慎使用。\n3.强制类型转换常见场景 浮点数转整数\n截断小数部分 长整型转整型\n可能溢出，超出 int 范围的数据会发生溢出 示例：\nlong l = 300; byte b = (byte) l; // 可能溢出 System.out.println(b); 字符型与整型互转\nchar c = 'A'; int i = (int)c; 输出 65 int i = 66; char c = (char)i; 输出 B 4.类型转换的注意事项 自动类型转换一般安全，但可能出现精度问题 强制类型转换要注意数据范围和溢出 进行运算时，如果数据类型不同，Java 会先进行自动类型提升，再执行运算 关键字与标识符（Keyword and Identifier） 1.什么是关键字？ 关键字（Keyword）是 Java语言中已经被赋予特定含义的单词。\n这些单词在程序中被 保留 供 Java 自己使用，我们 不能用它们来命名变量、类、方法或对象。\n2.常见关键字分类(截止至Java17) 类别 关键字 访问控制 public, private, protected 类、对象、接口 class, interface, extends, implements, new 方法与返回 void, return, abstract, native, static, synchronized 数据类型 int, double, float, char, byte, short, long, boolean 控制语句 if, else, switch, case, default, for, while, do, break, continue 异常处理 try, catch, finally, throw, throws 包与导入 package, import 布尔值与空值 true, false, null 其他常用 this, super, final, const（保留）, goto（保留）, enum, assert, instanceof 信息\n注意：const 和 goto 是 Java 中的 保留字，目前没有实际用途，但 不能用作标识符。\n示例：\nint class = 10; // ❌ 报错，class 是关键字 int Class = 10; // ✅ 合法，区分大小写 注释\n关键字的种类繁多，现阶段只做了解，随着我们后面的学习会慢慢熟悉，现在不认识也没关系，一些初次接触的关键字我会在代码中的注释里进行介绍\n3.什么是标识符？ 标识符（Identifier） 是程序员为 类名、变量名、方法名、包名等自定义的名称，用来标识程序中的各种元素。\n我们前面所学的变量中所定义的变量名就是一种标识符\n简单来说，标识符就是程序中的“名字”。\n例如：\nint age = 18; // age 是变量名（标识符） String name = \u0026#34;Tom\u0026#34;; // name 是变量名（标识符） class Student { // Student 是类名（标识符） void study() { // study 是方法名（标识符） System.out.println(\u0026#34;学习中...\u0026#34;); } } 4.标识符的命名规则和命名规范 命名规则(必须遵守) 由 字母（A-Z / a-z）、数字（0-9）、下划线 _ 和 美元符号 $ 组成。\n不能以数字开头。\n不能是关键字。\n严格区分大小写。（Name 和 name 是两个不同的标识符） 示例：\n合法标识符 非法标识符 age, _count, sum1, $price 1abc, class, public, my-name 在以上非法标识符中：\n1abc:以数字开头，不合法 class,public:标识符不能为关键字 my-name:标识符必须由字母（A-Z / a-z）、数字（0-9）、下划线 _ 和 美元符号 $ 组成，\u0026quot;-\u0026ldquo;不包含在内 命名规范(建议遵守) 虽然 Java 不强制要求命名风格，但良好的命名规范能显著提高代码可读性。\n这也就是我们所说的命名的最佳实践\n类型 规范示例 命名规则 类名 Student, PersonInfo 首字母大写，每个单词首字母大写（大驼峰） 变量名 age, studentName 首字母小写，从第二个单词起首字母大写（小驼峰） 方法名 getName(), calculateSum() 与变量相同，小驼峰命名 常量名 MAX_VALUE, PI 全部大写，单词间用下划线连接 5.null与标识符的关系 null是一个特殊的字面量常量，表示“空引用”，不是关键字，但具有类似地位。 它可以赋给引用类型的变量，用来表示该变量目前没有指向任何对象。 例如：\nString name1 = \u0026#34;SteamedFish\u0026#34;//定义一个String字符串对象 String name2 = null; // 表示 name 没有引用任何字符串对象 name1 是指向 \u0026ldquo;SteamedFish\u0026rdquo; 字符串对象的引用。\nname2 被赋值为 null，表示它目前没有引用任何对象。\n注释\nnull不能作为标识符使用，它虽然不是关键字，但同样被 Java 语言保留。\n运算符(Operator) 1.什么是运算符 运算符（Operator）是对数据（操作数）进行运算的符号。 简单来说，就是让 Java 能计算、比较、逻辑判断的“符号工具”。\nint sum = 3 + 5; // + 是运算符 // 这里定义了一个整数类型变量 sum，并让它等于 3 + 5 的结果 这里的 + 就是一个算术运算符，它让两个数进行加法操作。\n2.运算符与操作数 在表达式中，运算符作用于一个或多个操作数（Operand）：\n一元运算符：只作用于一个操作数，如 ++a\n二元运算符：作用于两个操作数，如 a + b\n三元运算符：作用于三个操作数，如 a \u0026gt; b ? a : b\n在上面的例子：3 + 5中的+就是一个二元操作符，它的两个操作数是3和5\n运算符分类总览 类别 示例 说明 算术运算符 +,-,*,/,% 用于执行加减乘除、取余等数值计算 赋值运算符 =, +=, -=, *=, /=, %= 用于给变量赋值或进行复合赋值 关系运算符 \u0026gt;,\u0026lt;,\u0026gt;=,\u0026lt;=,==,!= 用于比较两个值，结果为 true 或 false 逻辑运算符 \u0026amp;,|,!,^,\u0026amp;\u0026amp;,|| 用于连接多个布尔表达式，进行逻辑判断 自增自减 ++,-- 让变量自增或自减 1 条件运算符 ?: 三元判断：简化条件判断的写法 位运算符 \u0026amp;,|,^,~,\u0026lt;\u0026lt;,\u0026gt;\u0026gt;,\u0026gt;\u0026gt;\u0026gt; 直接对二进制位进行操作，用于底层运算 算数运算符详解 基本运算符：+ - * / % int a = 10, b = 3; System.out.println(a + b); // 13 System.out.println(a - b); // 7 System.out.println(a * b); // 30 System.out.println(a / b); // 3（整数除法） System.out.println(a % b); // 1（取余） ⚠️ 注意：当两个整数相除时，结果仍为整数，小数部分会被截断。 如：在数学中5/2=2.5，但在整形运算中5/2=2，小数部分的0.5被截断 若想保留小数结果，应使用浮点类型：\ndouble result = 10.0 / 3; System.out.println(result); // 3.3333333 自动类型提升 当不同类型数据混合运算时，Java 会自动将“低精度类型”转换为“高精度类型”：\nint i = 5; double d = 3.2; System.out.println(i + d); // 输出 8.2 因为 int 会被自动提升为 double。\n常见问题 System.out.println(10 / 4); // 输出 2，不是 2.5 System.out.println(10.0 / 4); // 输出 2.5 整数除法结果始终为整数，小数会被舍弃！\n赋值运算符(Assignment Operators) 赋值运算符用于给变量赋值。 在前面的学习中我们经常见到的 = 就是一个赋值符号。 =是最基本的赋值符号\n基本赋值符号 int a = 10; a = a + 5; 复合赋值符号 复合赋值运算符是赋值与运算的简写形式。\n运算符 等价形式 示例 说明 += a = a + b a += 3 加后赋值 -= a = a - b a -= 2 减后赋值 *= a = a * b a *= 2 乘后赋值 /= a = a / b a /= 2 除后赋值 %= a = a % b a %= 3 取余后赋值 示例：\nint x = 10; x += 5; // 等价于 x = x + 5 -\u0026gt; x = 10 +5 -\u0026gt; x = 15 System.out.println(x); // 15 关系运算符(Relational Operators) 关系运算符用于比较两个值，结果为布尔类型 true 或 false。\n运算符 示例 结果说明 \u0026gt; 5 \u0026gt; 3 → true 大于 \u0026lt; 2 \u0026lt; 8 → true 小于 \u0026gt;= 5 \u0026gt;= 5 → true 大于等于 \u0026lt;= 4 \u0026lt;= 6 → true 小于等于 == 10 == 10 → true 等于 != 5 != 3 → true 不等于 ⚠️ 注意：\n比较 基本类型 使用 ==， 比较 引用类型（如 String） 要用 .equals()。\nString a = new String(\u0026#34;Java\u0026#34;); String b = new String(\u0026#34;Java\u0026#34;); System.out.println(a == b); // false（比较的是地址） System.out.println(a.equals(b)); // true（比较的是内容） 逻辑运算符(Logical Operators) 逻辑运算符用于连接布尔表达式，结果为布尔值 true 或 false。\n分为短路逻辑运算符和非短路逻辑运算符。\n运算符 名称 示例 说明 \u0026amp;\u0026amp; 短路与 A \u0026amp;\u0026amp; B 若A为false，B不再执行 || 短路或 A || B 若A为true，B不再执行 ! 逻辑非 !A 取反 \u0026amp; 逻辑与（非短路） A \u0026amp; B 两边都执行 | 逻辑或（非短路） A | B 两边都执行 ^ 逻辑异或 A ^ B 相同为假，不同为真 \u0026amp;与|的区别： \u0026amp;逻辑与：在进行判断时，A 与 B都为真则输出真(true)，否则为假(false) 即：A 与 B只要一个逻辑为假，则输出假(false) |逻辑或：在进行判断时，A 或 B只要一个为真则输出真(true),否则为假(false)\n即：A 与 B都为假，则输出假(false) \u0026amp;与\u0026amp;\u0026amp;的区别: \u0026amp;逻辑与：在进行判断时，先判断A，再判断B \u0026amp;\u0026amp;短路与：在进行判断时，先判断A，当A为false，则直接输出false时，不会再对B进行判断 |与||的区别: |逻辑或：在进行判断时，先判断A，再判断B ||短路或：在进行判断时，先判断A，如果A为true，则直接输出teur，不会再对B进行判断 ^的解析： ^逻辑异或：A 或 B逻辑结果不同时，输出true A 与 B逻辑相同，即都为true或者false时，输出false 可以看到，^逻辑异或，追求的是逻辑上的\u0026rdquo;异\u0026quot;，只有两边条件不同时才输出true 自增自减运算符（++、\u0026ndash;） 这两个运算符常用于计数与循环。\n符号 含义 ++a 先加后用 a++ 先用后加 示例： int a = 1; System.out.println(++a); // 2 //a=1，要输出++a，先对a进行自增 //即：a += 1 --\u0026gt; a = a + 1 --\u0026gt; a = 1 + 1 --\u0026gt; a = 1 int a = 1; System.out.println(a++); // 1 System.out.println(a); // 2 //要输出a++，先引用a，引用a之后才对a进行自增 //则直接输出a，a=1，所以直接输出1 //下一条语句要输出a，此时a在被第一次次引用时已经进行了自增 //所以输出2 条件（三元）运算符 格式：\n条件表达式 ? 表达式1 : 表达式2; 若条件为 true，执行表达式1 否则执行表达式2 示例： int age = 20; String result = (age \u0026gt;= 18) ? \u0026#34;成年人\u0026#34; : \u0026#34;未成年\u0026#34;; //条件表达式为age \u0026gt;= 18，age为20，所以age\u0026gt;=18为真(true) //条件表达式为真，执行表达式1，即字符串result=\u0026#34;成年了\u0026#34; System.out.println(result); // 成年人 //输出result 位运算符(Bitwise Operators) 位运算直接操作整数的二进制位。\n运算符 含义 示例 结果（二进制） \u0026amp; 按位与 5 \u0026amp; 3 0101 \u0026amp; 0011 = 0001 (1) | 按位或 5 | 3 0101 | 0011 = 0111 (7) ^ 按位异或 5 ^ 3 0101 ^ 0011 = 0110 (6) ~ 按位取反 ~5 1010 (-6) \u0026lt;\u0026lt; 左移 5 \u0026lt;\u0026lt; 1 10 \u0026gt;\u0026gt; 右移 5 \u0026gt;\u0026gt; 1 2 \u0026gt;\u0026gt;\u0026gt; 无符号右移 对正数与 \u0026gt;\u0026gt; 相同 \u0026lt; 位运算是直接对整数的二进制进行的运算 注释\n所有数据在计算机底层都是通过二进制的补码进行存储和运算的 这部分实在太底层了，懒得讲了 在Java中我们用的很少 感兴趣的同学可以自行搜索资料学习\n关键词：位运算、原码、反码、补码、二进制、c语言\n运算符优先级表 在表达式中，哪个运算符先执行后执行是要看优先级的 信息\n这里着重记住 ()的优先级是最高的\n优先级 运算符 说明 1 () 括号 2 ++, --, !, ~ 单目运算 3 *, /, % 乘除取余 4 +, - 加减 5 \u0026lt;\u0026lt;, \u0026gt;\u0026gt;, \u0026gt;\u0026gt;\u0026gt; 位移 6 \u0026lt;, \u0026lt;=, \u0026gt;, \u0026gt;=, instanceof 比较 7 ==, != 相等 8 \u0026amp; 按位与 9 ^ 按位异或 10 | 按位或 11 \u0026amp;\u0026amp; 逻辑与 12 || 逻辑或 13 ?: 条件运算符 14 =, +=, -=, *= 等 赋值 15 , 逗号（最低） ","permalink":"https://www.steamedfish.top/post/java-se-basics-tutorial/","summary":"\u003ch2 id=\"前言\"\u003e前言\u003c/h2\u003e\n\u003cp\u003e本文作为JavaSE系列的第一篇文章，我会尽可能的解释一些基础知识和常用的编辑器（本文统一使用 \u003cstrong\u003eIDEA\u003c/strong\u003e ）操作并附上图片说明，但本文过后我将不再过多赘述，若有读者遇见不懂的难题，可以翻看本篇文章或自行查阅相关资料。\u003c/p\u003e\n\u003cp\u003e关于我的系统环境以及Java、JavaSE、SDK、JVM是什么？等等问题，后面可能会出一篇《JavaSE前置篇》来进行说明，但目前没有这个打算，因为一开始想写这个系列，也仅仅是想对之前学习的一些知识进行一个归纳和总结。 \u003cbr\u003e\n或许写完JavaSE系列后可能会抽出空来进行补充。\u003c/p\u003e","title":"Java SE从入门到跑路（一·基础语法篇）"},{"content":"这篇文章不仅仅是介绍，也是学习\nMarkdown 是一种轻量级标记语言，由 John Gruber 在 2004 年创建。它使用纯文本格式编写文档，通过简单的符号标记实现格式化，例如标题、列表、加粗、斜体等。Markdown 可以方便地转换为 HTML、PDF、Word等格式，广泛应用于博客、文档和笔记工具。\n用我自己的话来说，总结它的三个优点就是“轻量、可读、跨平台”\n轻量（Lightweight） 语法简单，不依赖复杂工具。\n文件体积小，便于编辑和存储。\n可读（Readable） 即使不渲染，也能清晰看到排版结构。\n文本和格式分离，减少干扰。\n跨平台（Cross-platform） 纯文本文件，可在任意操作系统和编辑器打开。\n支持多种博客、文档系统，便于内容迁移。\nMarkdown基本语法 标题 在Markdown中最多支持六级标题。 使用\u0026quot;#\u0026quot; 来表示标题等级，\u0026quot;#\u0026quot; 的数量对应标题级别。\n但是应要注意，#与标题之间要留有一个空格 级别\rMarkdown语法\r渲染效果\r一级标题\r# H1 一级标题\rH1 一级标题\r二级标题\r## H2 二级标题\rH2 二级标题\r三级标题\r### H3 三级标题\rH3 三级标题\r四级标题\r#### H4 四级标题\rH4 四级标题\r五级标题\r##### H5 五级标题\rH5 五级标题\r六级标题\r###### H6 六级标题\rH6 六级标题\r或者，在文本下方的行中，添加任意数量的 == 字符表示一级标题，或 \u0026ndash; 字符表示二级标题。 级别\rMarkdown 写法\r渲染效果\r一级标题\rH1 一级标题\r=======\rH1 一级标题\r二级标题\rH2 二级标题\r-------\rH2 二级标题\r一个容易被忽略的细节：\nMarkdown 语法要求在标题和其他文本之间留出一个空行，以保证渲染正常。 否则在部分渲染器（尤其是 Hugo、GitHub Pages 或一些编辑器）中， 标题和文字可能会粘在一起、解析错误或样式异常。\n段落 用 空行 分隔一行或多行文本\n换行 要创建换行或新行，请使用两个或更多 空格 结束一行，然后键入回车。 个人比较喜欢用Tab键，方便、实用。\n强调 你可以通过加粗或斜体文本来添加强调。\n加粗 要加粗文本，请在单词或短语前和后添加两个星号或下划线。要加粗单词中间的内容以示强调，请在字母周围添加两个星号，中间不要有空格。 Markdown 写法\r渲染效果\r**加粗文本1**\r加粗文本1\r__加粗文本2__\r加粗文本2\r斜体 要将文本斜体化，请在单词或短语前和后添加一个星号或下划线。要斜体化单词中间的内容以示强调，请在字母周围添加一个星号，中间不要有空格。 Markdown 写法\r渲染效果\r*斜体文本1*\r斜体文本1\r_斜体文本2_\r斜体文本2\r加粗和斜体 要同时使用加粗和斜体 来强调文本，请在单词或短语前和后添加三个星号或下划线。要加粗和斜体化单词中间的内容以示强调，请在字母周围添加三个星号，中间不要有空格。 Markdown 写法\r渲染效果\r***加粗斜体文本1***\r加粗斜体文本1\r___加粗斜体文本2___\r加粗斜体文本2\r引用块 要创建引用块，请在段落前添加 \u0026gt;，引用是以段落为单位的 Markdown 写法\r渲染效果\r\u003e引用第一段第一行\r第一段第二行\r第二段\r引用第一段第一行\n第一段第二行\r第二段\r在段落之间的空白行上添加 \u0026gt; ，引用块就可以包含多个段落。 Markdown 写法\r渲染效果\r\u003e引用第一段第一行\r第一段第二行\r\u003e\r\u003e第二段\r引用第一段第一行\n第一段第二行\n第二段\r嵌套引用块 在要嵌套的段落前添加 \u0026raquo;，可以进行引用块的嵌套 Markdown 写法\r渲染效果\r\u003e引用块\r\u003e\u003e嵌套引用块\r引用块\r嵌套引用块\r包含其他元素的引用块 引用块可以包含其他 Markdown 格式的元素。并非所有元素都可以使用——你需要进行实验以查看哪些元素有效。\n引用块+四级标题 引用块+列表 斜体 + 加粗. 列表 列表分为有序列表和无序列表\n有序列表 要创建有序列表，请添加带有数字和句号的行项目。数字不必按数字顺序排列，Markdown会自动渲染它，但列表应从数字一开头。\n列表标识符 和 项目 之间应保留一个 空格 Markdown 写法\r渲染效果\r1. 第一项\r2. 第二项\r1. 第二项的子项\r2. 第二项的子项\r3. 第三项\r第一项\r第二项\r第二项的子项\r第二项的子项\r第三项\r无序列表 要创建无序列表，请在行项目前添加破折号 (-)、星号 (*) 或加号 (+)。缩进一个或多个项目以创建嵌套列表。 Markdown 写法\r渲染效果\r- 第一项\r- 第二项\r- 第三项\r- 缩进项\r- 缩进项\r- 第四项\r第一项\r第二项\r第三项\r缩进项\r缩进项\r第四项\r用数字开始无序列表项 如果你需要用一个数字和一个句号开始一个无序列表项，数字和( 英文 )句号的组合可能被误认为成列表标识符，可以使用反斜杠 ( \\ ) 来转义句号。 Markdown 写法\r渲染效果\r- 2003\\. 伟大的一年！\r- 那 2004 年是第二好的。\r2003. 伟大的一年！\r那 2004 年是第二好的。\r在列表中添加元素 要在列表中添加另一个元素，同时保留列表的连续性，请将元素缩进四个空格或一个制表符，如下例所示 信息\n如果渲染效果没有按预期出现，请仔细检查你是否已将列表中的元素缩进了四个空格或一个制表符。\n段落 Markdown 写法\r渲染效果\r* 这是第一个列表项。\r* 这是第二个列表项。\r第二个列表项下方添加另一个段落。\r* 这是第三个列表项。\r这是第一个列表项。\r这是第二个列表项。\r第二个列表项下方添加另一个段落。\r这是第三个列表项。\r引用块 Markdown 写法\r渲染效果\r* 这是第一个列表项。\r* 这是第二个列表项。\r\u003e第二个列表项下方显示一个引用块\r* 这是第三个列表项。\r这是第一个列表项。\r这是第二个列表项。\r第二个列表项下方显示一个引用块\r这是第三个列表项。\r代码块 代码块 通常缩进四个空格或一个制表符。当它们在列表中时，将它们缩进八个空格或两个制表符。 Markdown 写法\r渲染效果\r1. 这是第一个列表项。\r1. 这是第二个列表项。\r第二个列表项下方显示一个代码块\r2. 这是第三个列表项。\r这是第一个列表项。\r这是第二个列表项。\r第二个列表项下方显示一个代码块\r这是第三个列表项。\r图像 Markdown 写法\r渲染效果\r1. 这是第一个列表项。\r1. 这是第二个列表项。\r![logo](/imges/dead-fish.png)\r2. 这是第三个列表项。\r这是第一个列表项。\r这是第二个列表项。\r这是第三个列表项。\r代码 要表示一个单词或短语为代码，请用反引号 ( ` ) 将其括起来。\nMarkdown写法 渲染效果 `code` code 转义反引号 如果你要表示为代码的单词或短语包含一个或多个反引号，你可以通过用双反引号 ( `` ) 将单词或短语括起来来转义它。\nMarkdown写法 渲染效果 ``在你的 Markdown 文件中使用 `code`。`` 在你的 Markdown 文件中使用 `code`。 代码块 要创建代码块，请将块的每一行至少缩进四个空格或一个制表符。\n\u0026lt;html\u0026gt;\r\u0026lt;head\u0026gt;\r这是个代码块\r\u0026lt;/head\u0026gt;\r\u0026lt;/html\u0026gt;\r信息\n要创建不缩进行的代码块，请使用 围栏代码块。\n水平线 要创建水平线，请在单独的一行上使用三个或更多星号 (***)、破折号 (\u0026mdash;) 或下划线 (___)。\n***\r---\r___\r三种方式的渲染输出看起来是一样的\nLike this👆\n链接 要创建链接，请用方括号括住链接文本，例如，[github]，然后括号中紧跟 URL，例如，(https://github.com/)。\n[世界上最大的同性交友网站](https://github.com/)\n输出如下所示：\n世界上最大的同性交友网站 信息\n要链接到同一页面上的元素，请参阅 链接到标题 ID。要创建在新标签或窗口中打开的链接，请参阅 链接目标 部分。\n添加标题 你可以选择为链接添加标题。当用户将鼠标悬停在链接上时，它将显示为工具提示。要添加标题，请在 URL 后用引号将其括起来。\n我最喜欢的网站是[Github](https://github.com/\u0026quot;世界上最大的同性交友网站\u0026quot;)\n输出如下所示：\n我最喜欢的网站是Github 鼠标悬停在此查看效果👆\nURL和电子邮件地址 要快速将 URL 或电子邮件地址变成链接，请用尖括号将其括起来。\nMarkdown写法 渲染效果 \u0026lt;https://www.steamedfish.top/\u0026gt; https://www.steamedfish.top/ \u0026lt;fake@example.com\u0026gt; fake@example.com 注释\n实测Hogo支持直接将URL和邮件渲染成地址，不写\u0026lt;\u0026gt;的情况下依然能够显示\n格式化链接 要 强调 链接，请在方括号和圆括号前后添加星号。要将链接表示为 代码，请在方括号中添加反引号。\nMarkdown写法 渲染效果 加粗链接 **[SteamedFishBlog](https://www.steamedfish.top/)**. 加粗链接 SteamedFishBlog. 斜体链接 *[Markdown Guide](http://markdownguide.cn)*. 斜体链接 Markdown Guide. 参阅[`代码`](#代码) 参阅代码 引用式链接 引用式链接是一种特殊的链接，它使 URL 在 Markdown 中更易于显示和阅读。引用式链接由两部分构成：一部分与文本保持一致，另一部分存储在文件中的其他位置，以保持文本易于阅读。\n引用式链接的第一部分 引用式链接的第一部分使用两组方括号进行格式化。第一组方括号包围应显示为链接的文本。第二组方括号显示用于指向存储在文档其他位置的链接的标签。\n虽然不是必需的，但你可以在第一组和第二组方括号之间添加空格。第二组方括号中的标签不区分大小写，并且可以包含字母、数字、空格或标点符号。\n这意味着以下示例格式对于链接的第一部分大致相同\n博客主页 [博客主页] 1 格式化链接的第二部分 参考样式链接的第二部分使用以下属性进行格式化\n1.标签，用方括号括起来，紧跟一个冒号和至少一个空格（例如，[label]: ）。 2.链接的 URL，你可以选择用尖括号括起来。 3.链接的可选标题，可以用双引号、单引号或括号括起来。\n这意味着以下示例格式对于链接的第二部分来说大致相等\n[1]: https://www.steamedfish.top/ [1]: https://www.steamedfish.top/ \u0026quot;我的播客主页\u0026quot; [1]: https://www.steamedfish.top/ '我的播客主页' [1]: https://www.steamedfish.top/ (我的播客主页) [1]: \u0026lt;https://www.steamedfish.top/\u0026gt; \u0026quot;我的播客主页\u0026quot; [1]: \u0026lt;https://www.steamedfish.top/\u0026gt; '我的播客主页' [1]: \u0026lt;https://www.steamedfish.top/\u0026gt; (我的播客主页) 你可以将链接的第二部分放在 Markdown 文档中的任何位置。有些人将它们放在它们出现的段落之后，而另一些人将它们放在文档的末尾（如尾注或脚注）。\n将各部分放在一起的示例 假设你将一个 URL 作为 标准 URL 链接 添加到一个段落，并且在 Markdown 中看起来像这样\n欢迎来到我的博客，这是我的[博客主页](www.steamedfish.top)，这里记录技术、生活和学习！\r虽然它可能指向有趣的附加信息，但显示的 URL 除了使其更难阅读之外，实际上并没有给现有原始文本增加太多内容。要解决这个问题，你可以像这样格式化 URL\n欢迎来到我的博客，这是我的[博客主页][1]，这里记录技术、生活和学习！\r[1]: \u0026lt;https://www.steamedfish.top/\u0026gt; \u0026quot;我的博客主页\u0026quot;\r在上面的两个实例中，呈现的输出将是相同的\n欢迎来到我的博客，这是我的博客主页，这里记录技术、生活和学习！\n图像 要添加图片，添加一个感叹号 ( ! )，后跟方括号中的备用文本，以及括号中图片资源的路径或 URL。你可以在路径或 URL 后添加引号中的标题（可选）。\n![The San Juan Mountains are beautiful!](/assets/images/san-juan-mountains.jpg \u0026quot;San Juan Mountains\u0026quot;)\n呈现的效果如下所示 链接图片 要向图片添加链接，请用方括号括住图片的 Markdown，然后在括号中添加链接。\n[![An old rock in the desert](/images/shiprock.jpg)](/images/shiprock.jpg) 呈现的效果如下所示 转义字符 要显示一个文本字符，该字符原本用于格式化 Markdown 文档中的文本，请在字符前面添加一个反斜杠 (\\)。\n\\* 如果没有反斜杠，这将是无序列表中的项目符号。\n呈现的效果如下所示\n* 如果没有反斜杠，这将是无序列表中的项目符号。\n可以转义的字符 可以使用反斜杠转义以下字符。\n字符 名称 \\ 反斜杠 `` 反引号（另请参阅 代码中的转义反引号） * 星号 _ 下划线 { } 大括号 [ ] 方括号 \u0026lt; \u0026gt; 尖括号 ( ) 圆括号 # 井号 + 加号 - 减号（连字符） . 点 ! 感叹号 | 管道（另请参阅 表格中转义管道） HTML 许多 Markdown 应用程序允许你在 Markdown 格式文本中使用 HTML 标签。如果你更喜欢某些 HTML 标签而不是 Markdown 语法，这会很有帮助。例如，有些人觉得使用 HTML 标签来处理图片更简单。当你需要更改元素的属性（例如指定 文本颜色 或更改图片的宽度）时，使用 HTML 也会很有帮助。\n要使用 HTML，请将标签放置在 Markdown 格式文件文本中。\n这个 **词语** 是粗体，这个\u0026lt;em\u0026gt;词语\u0026lt;/em\u0026gt; 是斜体。\n这个 词语 是粗体，这个词语 是斜体。 信息\n在Hugo中默认不支持HTML的输出，至于具体需要怎么做，需要你对Hugo的内容组织和文件架构有一定了解，以后主播会重新写一篇文章详细介绍的(先鸽着吧)\nHTML最佳实践 出于安全原因，并非所有 Markdown 应用程序都支持 Markdown 文档中的 HTML。如有疑问，请查看 Markdown 应用程序的文档。一些应用程序仅支持 HTML 标签的子集。\n使用空行来分隔块级 HTML 元素，如 \u0026lt;div\u0026gt;、\u0026lt;table\u0026gt;、\u0026lt;pre\u0026gt; 和 \u0026lt;p\u0026gt;，使其与周围内容分开。尽量不要使用制表符或空格缩进标签，因为这会影响格式。\n你不能在块级 HTML 标签中使用 Markdown 语法。例如，\u0026lt;p\u0026gt;italic and **bold**\u0026lt;/p\u0026gt; 将不起作用。 注释\n说的直白点就是在你写的HTML块中，Markdown语法将不再生效\n","permalink":"https://www.steamedfish.top/post/markdown-basic-syntax/","summary":"\u003cp\u003e这篇文章不仅仅是介绍，也是学习\u003c/p\u003e\n\u003cp\u003e\u003cimg alt=\"MSG\" loading=\"lazy\" src=\"/images/msg.png\"\u003e\u003c/p\u003e\n\u003cp\u003eMarkdown 是一种轻量级标记语言，由 John Gruber 在 2004 年创建。它使用纯文本格式编写文档，通过简单的符号标记实现格式化，例如标题、列表、加粗、斜体等。Markdown 可以方便地转换为 HTML、PDF、Word等格式，广泛应用于博客、文档和笔记工具。\u003c/p\u003e","title":"Markdown基础语法"},{"content":"","permalink":"https://www.steamedfish.top/about/","summary":"","title":""},{"content":"","permalink":"https://www.steamedfish.top/archives/","summary":"","title":""}]